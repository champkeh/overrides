/*! For license information please see course-player.0c34bb1fb7c0a4f6bac7.js.LICENSE.txt */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

"use strict";
self.webpackChunk = self.webpackChunk || []
self.webpackChunk.push(
    [
        [7209],
        {
            6258: function (module, exports, require) {
                require.d(exports, {
                    BH: function () {
                        return _
                    },
                    DV: function () {
                        return V
                    },
                    GJ: function () {
                        return x
                    },
                    L: function () {
                        return l
                    },
                    LL: function () {
                        return P
                    },
                    P0: function () {
                        return v
                    },
                    Pz: function () {
                        return w
                    },
                    Sg: function () {
                        return b
                    },
                    UI: function () {
                        return z
                    },
                    US: function () {
                        return a
                    },
                    Wl: function () {
                        return L
                    },
                    Yr: function () {
                        return R
                    },
                    ZR: function () {
                        return FirebaseError
                    },
                    aH: function () {
                        return y
                    },
                    b$: function () {
                        return k
                    },
                    cI: function () {
                        return D
                    },
                    dS: function () {
                        return Q
                    },
                    eu: function () {
                        return O
                    },
                    g5: function () {
                        return s
                    },
                    gK: function () {
                        return Y
                    },
                    gQ: function () {
                        return K
                    },
                    h$: function () {
                        return u
                    },
                    hl: function () {
                        return A
                    },
                    hu: function () {
                        return i
                    },
                    m9: function () {
                        return ee
                    },
                    ne: function () {
                        return J
                    },
                    p$: function () {
                        return d
                    },
                    pd: function () {
                        return q
                    },
                    q4: function () {
                        return g
                    },
                    r3: function () {
                        return F
                    },
                    ru: function () {
                        return E
                    },
                    tV: function () {
                        return h
                    },
                    uI: function () {
                        return T
                    },
                    ug: function () {
                        return Z
                    },
                    vZ: function () {
                        return $
                    },
                    w1: function () {
                        return S
                    },
                    w9: function () {
                        return U
                    },
                    xO: function () {
                        return H
                    },
                    xb: function () {
                        return j
                    },
                    z$: function () {
                        return I
                    },
                    zd: function () {
                        return W
                    }
                });
                const r = {
                        NODE_CLIENT: false,
                        NODE_ADMIN: false,
                        SDK_VERSION: "${JSCORE_VERSION}"
                    },
                    i = function (e, t) {
                        if (!e)
                            throw s(t)
                    },
                    s = function (e) {
                        return new Error("Firebase Database (" + r.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + e)
                    },
                    o = function (e) {
                        const t = [];
                        let n = 0;
                        for (let r = 0; r < e.length; r++) {
                            let i = e.charCodeAt(r);
                            i < 128 ? t[n++] = i : i < 2048 ? (t[n++] = i >> 6 | 192,
                                t[n++] = 63 & i | 128) : 55296 == (64512 & i) && r + 1 < e.length && 56320 == (64512 & e.charCodeAt(r + 1)) ? (i = 65536 + ((1023 & i) << 10) + (1023 & e.charCodeAt(++r)),
                                t[n++] = i >> 18 | 240,
                                t[n++] = i >> 12 & 63 | 128,
                                t[n++] = i >> 6 & 63 | 128,
                                t[n++] = 63 & i | 128) : (t[n++] = i >> 12 | 224,
                                t[n++] = i >> 6 & 63 | 128,
                                t[n++] = 63 & i | 128)
                        }
                        return t
                    },
                    a = {
                        byteToCharMap_: null,
                        charToByteMap_: null,
                        byteToCharMapWebSafe_: null,
                        charToByteMapWebSafe_: null,
                        ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
                        get ENCODED_VALS() {
                            return this.ENCODED_VALS_BASE + "+/="
                        },
                        get ENCODED_VALS_WEBSAFE() {
                            return this.ENCODED_VALS_BASE + "-_."
                        },
                        HAS_NATIVE_SUPPORT: "function" == typeof atob,
                        encodeByteArray(e, t) {
                            if (!Array.isArray(e))
                                throw Error("encodeByteArray takes an array as a parameter");
                            this.init_();
                            const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_
                                , r = [];
                            for (let t = 0; t < e.length; t += 3) {
                                const i = e[t]
                                    , s = t + 1 < e.length
                                    , o = s ? e[t + 1] : 0
                                    , a = t + 2 < e.length
                                    , c = a ? e[t + 2] : 0
                                    , u = i >> 2
                                    , l = (3 & i) << 4 | o >> 4;
                                let h = (15 & o) << 2 | c >> 6
                                    , d = 63 & c;
                                a || (d = 64,
                                s || (h = 64)),
                                    r.push(n[u], n[l], n[h], n[d])
                            }
                            return r.join("")
                        },
                        encodeString(e, t) {
                            return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(o(e), t)
                        },
                        decodeString(e, t) {
                            return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : function (e) {
                                const t = [];
                                let n = 0
                                    , r = 0;
                                for (; n < e.length;) {
                                    const i = e[n++];
                                    if (i < 128)
                                        t[r++] = String.fromCharCode(i);
                                    else if (i > 191 && i < 224) {
                                        const s = e[n++];
                                        t[r++] = String.fromCharCode((31 & i) << 6 | 63 & s)
                                    } else if (i > 239 && i < 365) {
                                        const s = ((7 & i) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536;
                                        t[r++] = String.fromCharCode(55296 + (s >> 10)),
                                            t[r++] = String.fromCharCode(56320 + (1023 & s))
                                    } else {
                                        const s = e[n++]
                                            , o = e[n++];
                                        t[r++] = String.fromCharCode((15 & i) << 12 | (63 & s) << 6 | 63 & o)
                                    }
                                }
                                return t.join("")
                            }(this.decodeStringToByteArray(e, t))
                        },
                        decodeStringToByteArray(e, t) {
                            this.init_();
                            const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_
                                , r = [];
                            for (let t = 0; t < e.length;) {
                                const i = n[e.charAt(t++)]
                                    , s = t < e.length ? n[e.charAt(t)] : 0;
                                ++t;
                                const o = t < e.length ? n[e.charAt(t)] : 64;
                                ++t;
                                const a = t < e.length ? n[e.charAt(t)] : 64;
                                if (++t,
                                null == i || null == s || null == o || null == a)
                                    throw new DecodeBase64StringError;
                                const u = i << 2 | s >> 4;
                                if (r.push(u),
                                64 !== o) {
                                    const e = s << 4 & 240 | o >> 2;
                                    if (r.push(e),
                                    64 !== a) {
                                        const e = o << 6 & 192 | a;
                                        r.push(e)
                                    }
                                }
                            }
                            return r
                        },
                        init_() {
                            if (!this.byteToCharMap_) {
                                this.byteToCharMap_ = {},
                                    this.charToByteMap_ = {},
                                    this.byteToCharMapWebSafe_ = {},
                                    this.charToByteMapWebSafe_ = {};
                                for (let e = 0; e < this.ENCODED_VALS.length; e++)
                                    this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e),
                                        this.charToByteMap_[this.byteToCharMap_[e]] = e,
                                        this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e),
                                        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e,
                                    e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e,
                                        this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e)
                            }
                        }
                    };

                class DecodeBase64StringError extends Error {
                    constructor() {
                        super(...arguments)
                        this.name = "DecodeBase64StringError"
                    }
                }

                const u = function (e) {
                        const t = o(e);
                        return a.encodeByteArray(t, !0)
                    },
                    l = function (e) {
                        return u(e).replace(/\./g, "")
                    },
                    h = function (e) {
                        try {
                            return a.decodeString(e, !0)
                        } catch (e) {
                            console.error("base64Decode failed: ", e)
                        }
                        return null
                    };

                function d(e) {
                    return f(void 0, e)
                }

                function f(e, t) {
                    if (!(t instanceof Object))
                        return t;
                    switch (t.constructor) {
                        case Date:
                            return new Date(t.getTime());
                        case Object:
                            void 0 === e && (e = {});
                            break;
                        case Array:
                            e = [];
                            break;
                        default:
                            return t
                    }
                    for (const n in t)
                        t.hasOwnProperty(n) && "__proto__" !== n && (e[n] = f(e[n], t[n]));
                    return e
                }

                const p = () => function () {
                        if ("undefined" != typeof self)
                            return self;
                        if ("undefined" != typeof window)
                            return window;
                        if (void 0 !== require.g)
                            return require.g;
                        throw new Error("Unable to locate global object.")
                    }().__FIREBASE_DEFAULTS__
                    , m = () => {
                        try {
                            return p() || (() => {
                                    if ("undefined" == typeof process || void 0 === process.env)
                                        return;
                                    const e = process.env.__FIREBASE_DEFAULTS__;
                                    return e ? JSON.parse(e) : void 0
                                }
                            )() || (() => {
                                    if ("undefined" == typeof document)
                                        return;
                                    let e;
                                    try {
                                        e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
                                    } catch (e) {
                                        return
                                    }
                                    const t = e && h(e[1]);
                                    return t && JSON.parse(t)
                                }
                            )()
                        } catch (e) {
                            return void console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`)
                        }
                    }
                    , g = e => {
                        var t, n;
                        return null === (n = null === (t = m()) || void 0 === t ? void 0 : t.emulatorHosts) || void 0 === n ? void 0 : n[e]
                    }
                    , v = e => {
                        const t = g(e);
                        if (!t)
                            return;
                        const n = t.lastIndexOf(":");
                        if (n <= 0 || n + 1 === t.length)
                            throw new Error(`Invalid host ${t} with no separate hostname and port!`);
                        const r = parseInt(t.substring(n + 1), 10);
                        return "[" === t[0] ? [t.substring(1, n - 1), r] : [t.substring(0, n), r]
                    }
                    , y = () => {
                        var e;
                        return null === (e = m()) || void 0 === e ? void 0 : e.config
                    }
                    , w = e => {
                        var t;
                        return null === (t = m()) || void 0 === t ? void 0 : t[`_ ${e}`]
                    }
                ;

                class _ {
                    constructor() {
                        this.reject = () => {
                        }
                        this.resolve = () => {
                        }
                        this.promise = new Promise((resolve, reject) => {
                            this.resolve = resolve
                            this.reject = reject
                        })
                    }

                    wrapCallback(cb) {
                        return (err, val) => {
                            err ? this.reject(err) : this.resolve(val)
                            if ("function" == typeof cb) {
                                this.promise.catch(() => {
                                })
                                1 === cb.length ? cb(err) : cb(err, val)
                            }
                        }
                    }
                }

                function b(e, t) {
                    if (e.uid)
                        throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
                    const n = t || "demo-project"
                        , r = e.iat || 0
                        , i = e.sub || e.user_id;
                    if (!i)
                        throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
                    const s = Object.assign({
                        iss: `https://securetoken.google.com/${n}`,
                        aud: n,
                        iat: r,
                        exp: r + 3600,
                        auth_time: r,
                        sub: i,
                        user_id: i,
                        firebase: {
                            sign_in_provider: "custom",
                            identities: {}
                        }
                    }, e);
                    return [l(JSON.stringify({
                        alg: "none",
                        type: "JWT"
                    })), l(JSON.stringify(s)), ""].join(".")
                }

                function I() {
                    return "undefined" != typeof navigator && "string" == typeof navigator.userAgent ? navigator.userAgent : ""
                }

                function T() {
                    return "undefined" != typeof window && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(I())
                }

                function E() {
                    const e = "object" == typeof chrome ? chrome.runtime : "object" == typeof browser ? browser.runtime : void 0;
                    return "object" == typeof e && void 0 !== e.id
                }

                function k() {
                    return "object" == typeof navigator && "ReactNative" === navigator.product
                }

                function S() {
                    const e = I();
                    return e.indexOf("MSIE ") >= 0 || e.indexOf("Trident/") >= 0
                }

                function R() {
                    return !0 === r.NODE_CLIENT || !0 === r.NODE_ADMIN
                }

                function A() {
                    try {
                        return "object" == typeof indexedDB
                    } catch (e) {
                        return !1
                    }
                }

                function O() {
                    return new Promise(((e, t) => {
                            try {
                                let n = !0;
                                const r = "validate-browser-context-for-indexeddb-analytics-module"
                                    , i = self.indexedDB.open(r);
                                i.onsuccess = () => {
                                    i.result.close(),
                                    n || self.indexedDB.deleteDatabase(r),
                                        e(!0)
                                }
                                    ,
                                    i.onupgradeneeded = () => {
                                        n = !1
                                    }
                                    ,
                                    i.onerror = () => {
                                        var e;
                                        t((null === (e = i.error) || void 0 === e ? void 0 : e.message) || "")
                                    }
                            } catch (e) {
                                t(e)
                            }
                        }
                    ))
                }

                class FirebaseError extends Error {
                    constructor(code, t, customData) {
                        super(t)
                        this.code = code
                        this.customData = customData
                        this.name = "FirebaseError"
                        Object.setPrototypeOf(this, FirebaseError.prototype)
                        Error.captureStackTrace && Error.captureStackTrace(this, P.prototype.create)
                    }
                }

                class P {
                    constructor(e, t, n) {
                        this.service = e
                        this.serviceName = t
                        this.errors = n
                    }

                    create(e, ...t) {
                        const n = t[0] || {}
                            , r = `${this.service}/${e}`
                            , i = this.errors[e]
                            , s = i ? function (e, t) {
                            return e.replace(N, ((e, n) => {
                                    const r = t[n];
                                    return null != r ? String(r) : `<${n}?>`
                                }
                            ))
                        }(i, n) : "Error"
                            , o = `${this.serviceName}: ${s} (${r}).`;
                        return new FirebaseError(r, o, n)
                    }
                }

                const N = /\{\$([^}]+)}/g;

                function D(e) {
                    return JSON.parse(e)
                }

                function L(e) {
                    return JSON.stringify(e)
                }

                const M = function (e) {
                    let t = {}
                        , n = {}
                        , r = {}
                        , i = "";
                    try {
                        const s = e.split(".");
                        t = D(h(s[0]) || ""),
                            n = D(h(s[1]) || ""),
                            i = s[2],
                            r = n.d || {},
                            delete n.d
                    } catch (e) {
                    }
                    return {
                        header: t,
                        claims: n,
                        data: r,
                        signature: i
                    }
                }
                    , U = function (e) {
                    const t = M(e).claims;
                    return !!t && "object" == typeof t && t.hasOwnProperty("iat")
                }
                    , x = function (e) {
                    const t = M(e).claims;
                    return "object" == typeof t && !0 === t.admin
                };

                function F(e, t) {
                    return Object.prototype.hasOwnProperty.call(e, t)
                }

                function V(e, t) {
                    return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0
                }

                function j(e) {
                    for (const t in e)
                        if (Object.prototype.hasOwnProperty.call(e, t))
                            return !1;
                    return !0
                }

                function z(e, t, n) {
                    const r = {};
                    for (const i in e)
                        Object.prototype.hasOwnProperty.call(e, i) && (r[i] = t.call(n, e[i], i, e));
                    return r
                }

                function $(e, t) {
                    if (e === t)
                        return !0;
                    const n = Object.keys(e)
                        , r = Object.keys(t);
                    for (const i of n) {
                        if (!r.includes(i))
                            return !1;
                        const n = e[i]
                            , s = t[i];
                        if (B(n) && B(s)) {
                            if (!$(n, s))
                                return !1
                        } else if (n !== s)
                            return !1
                    }
                    for (const e of r)
                        if (!n.includes(e))
                            return !1;
                    return !0
                }

                function B(e) {
                    return null !== e && "object" == typeof e
                }

                function H(e) {
                    const t = [];
                    for (const [n, r] of Object.entries(e))
                        Array.isArray(r) ? r.forEach((e => {
                                t.push(encodeURIComponent(n) + "=" + encodeURIComponent(e))
                            }
                        )) : t.push(encodeURIComponent(n) + "=" + encodeURIComponent(r));
                    return t.length ? "&" + t.join("&") : ""
                }

                function W(e) {
                    const t = {};
                    return e.replace(/^\?/, "").split("&").forEach((e => {
                            if (e) {
                                const [n, r] = e.split("=");
                                t[decodeURIComponent(n)] = decodeURIComponent(r)
                            }
                        }
                    )),
                        t
                }

                function q(e) {
                    const t = e.indexOf("?");
                    if (!t)
                        return "";
                    const n = e.indexOf("#", t);
                    return e.substring(t, n > 0 ? n : void 0)
                }

                class K {
                    constructor() {
                        this.chain_ = [],
                            this.buf_ = [],
                            this.W_ = [],
                            this.pad_ = [],
                            this.inbuf_ = 0,
                            this.total_ = 0,
                            this.blockSize = 64,
                            this.pad_[0] = 128;
                        for (let e = 1; e < this.blockSize; ++e)
                            this.pad_[e] = 0;
                        this.reset()
                    }

                    reset() {
                        this.chain_[0] = 1732584193,
                            this.chain_[1] = 4023233417,
                            this.chain_[2] = 2562383102,
                            this.chain_[3] = 271733878,
                            this.chain_[4] = 3285377520,
                            this.inbuf_ = 0,
                            this.total_ = 0
                    }

                    compress_(e, t) {
                        t || (t = 0);
                        const n = this.W_;
                        if ("string" == typeof e)
                            for (let r = 0; r < 16; r++)
                                n[r] = e.charCodeAt(t) << 24 | e.charCodeAt(t + 1) << 16 | e.charCodeAt(t + 2) << 8 | e.charCodeAt(t + 3),
                                    t += 4;
                        else
                            for (let r = 0; r < 16; r++)
                                n[r] = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3],
                                    t += 4;
                        for (let e = 16; e < 80; e++) {
                            const t = n[e - 3] ^ n[e - 8] ^ n[e - 14] ^ n[e - 16];
                            n[e] = 4294967295 & (t << 1 | t >>> 31)
                        }
                        let r, i, s = this.chain_[0], o = this.chain_[1], a = this.chain_[2], c = this.chain_[3],
                            u = this.chain_[4];
                        for (let e = 0; e < 80; e++) {
                            e < 40 ? e < 20 ? (r = c ^ o & (a ^ c),
                                i = 1518500249) : (r = o ^ a ^ c,
                                i = 1859775393) : e < 60 ? (r = o & a | c & (o | a),
                                i = 2400959708) : (r = o ^ a ^ c,
                                i = 3395469782);
                            const t = (s << 5 | s >>> 27) + r + u + i + n[e] & 4294967295;
                            u = c,
                                c = a,
                                a = 4294967295 & (o << 30 | o >>> 2),
                                o = s,
                                s = t
                        }
                        this.chain_[0] = this.chain_[0] + s & 4294967295,
                            this.chain_[1] = this.chain_[1] + o & 4294967295,
                            this.chain_[2] = this.chain_[2] + a & 4294967295,
                            this.chain_[3] = this.chain_[3] + c & 4294967295,
                            this.chain_[4] = this.chain_[4] + u & 4294967295
                    }

                    update(e, t) {
                        if (null == e)
                            return;
                        void 0 === t && (t = e.length);
                        const n = t - this.blockSize;
                        let r = 0;
                        const i = this.buf_;
                        let s = this.inbuf_;
                        for (; r < t;) {
                            if (0 === s)
                                for (; r <= n;)
                                    this.compress_(e, r),
                                        r += this.blockSize;
                            if ("string" == typeof e) {
                                for (; r < t;)
                                    if (i[s] = e.charCodeAt(r),
                                        ++s,
                                        ++r,
                                    s === this.blockSize) {
                                        this.compress_(i),
                                            s = 0;
                                        break
                                    }
                            } else
                                for (; r < t;)
                                    if (i[s] = e[r],
                                        ++s,
                                        ++r,
                                    s === this.blockSize) {
                                        this.compress_(i),
                                            s = 0;
                                        break
                                    }
                        }
                        this.inbuf_ = s,
                            this.total_ += t
                    }

                    digest() {
                        const e = [];
                        let t = 8 * this.total_;
                        this.inbuf_ < 56 ? this.update(this.pad_, 56 - this.inbuf_) : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
                        for (let e = this.blockSize - 1; e >= 56; e--)
                            this.buf_[e] = 255 & t,
                                t /= 256;
                        this.compress_(this.buf_);
                        let n = 0;
                        for (let t = 0; t < 5; t++)
                            for (let r = 24; r >= 0; r -= 8)
                                e[n] = this.chain_[t] >> r & 255,
                                    ++n;
                        return e
                    }
                }

                function J(e, t) {
                    const n = new G(e, t);
                    return n.subscribe.bind(n)
                }

                class G {
                    constructor(e, t) {
                        this.observers = [],
                            this.unsubscribes = [],
                            this.observerCount = 0,
                            this.task = Promise.resolve(),
                            this.finalized = !1,
                            this.onNoObservers = t,
                            this.task.then((() => {
                                    e(this)
                                }
                            )).catch((e => {
                                    this.error(e)
                                }
                            ))
                    }

                    next(e) {
                        this.forEachObserver((t => {
                                t.next(e)
                            }
                        ))
                    }

                    error(e) {
                        this.forEachObserver((t => {
                                t.error(e)
                            }
                        )),
                            this.close(e)
                    }

                    complete() {
                        this.forEachObserver((e => {
                                e.complete()
                            }
                        )),
                            this.close()
                    }

                    subscribe(e, t, n) {
                        let r;
                        if (void 0 === e && void 0 === t && void 0 === n)
                            throw new Error("Missing Observer.");
                        r = function (e, t) {
                            if ("object" != typeof e || null === e)
                                return !1;
                            for (const n of t)
                                if (n in e && "function" == typeof e[n])
                                    return !0;
                            return !1
                        }(e, ["next", "error", "complete"]) ? e : {
                            next: e,
                            error: t,
                            complete: n
                        },
                        void 0 === r.next && (r.next = X),
                        void 0 === r.error && (r.error = X),
                        void 0 === r.complete && (r.complete = X);
                        const i = this.unsubscribeOne.bind(this, this.observers.length);
                        return this.finalized && this.task.then((() => {
                                try {
                                    this.finalError ? r.error(this.finalError) : r.complete()
                                } catch (e) {
                                }
                            }
                        )),
                            this.observers.push(r),
                            i
                    }

                    unsubscribeOne(e) {
                        void 0 !== this.observers && void 0 !== this.observers[e] && (delete this.observers[e],
                            this.observerCount -= 1,
                        0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this))
                    }

                    forEachObserver(e) {
                        if (!this.finalized)
                            for (let t = 0; t < this.observers.length; t++)
                                this.sendOne(t, e)
                    }

                    sendOne(e, t) {
                        this.task.then((() => {
                                if (void 0 !== this.observers && void 0 !== this.observers[e])
                                    try {
                                        t(this.observers[e])
                                    } catch (e) {
                                        "undefined" != typeof console && console.error && console.error(e)
                                    }
                            }
                        ))
                    }

                    close(e) {
                        this.finalized || (this.finalized = !0,
                        void 0 !== e && (this.finalError = e),
                            this.task.then((() => {
                                    this.observers = void 0,
                                        this.onNoObservers = void 0
                                }
                            )))
                    }
                }

                function X() {
                }

                function Y(e, t) {
                    return `${e} failed: ${t} argument `
                }

                const Q = function (e) {
                    const t = [];
                    let n = 0;
                    for (let r = 0; r < e.length; r++) {
                        let s = e.charCodeAt(r);
                        if (s >= 55296 && s <= 56319) {
                            const t = s - 55296;
                            r++,
                                i(r < e.length, "Surrogate pair missing trail surrogate.");
                            s = 65536 + (t << 10) + (e.charCodeAt(r) - 56320)
                        }
                        s < 128 ? t[n++] = s : s < 2048 ? (t[n++] = s >> 6 | 192,
                            t[n++] = 63 & s | 128) : s < 65536 ? (t[n++] = s >> 12 | 224,
                            t[n++] = s >> 6 & 63 | 128,
                            t[n++] = 63 & s | 128) : (t[n++] = s >> 18 | 240,
                            t[n++] = s >> 12 & 63 | 128,
                            t[n++] = s >> 6 & 63 | 128,
                            t[n++] = 63 & s | 128)
                    }
                    return t
                }
                    , Z = function (e) {
                    let t = 0;
                    for (let n = 0; n < e.length; n++) {
                        const r = e.charCodeAt(n);
                        r < 128 ? t++ : r < 2048 ? t += 2 : r >= 55296 && r <= 56319 ? (t += 4,
                            n++) : t += 3
                    }
                    return t
                };

                function ee(e) {
                    return e && e._delegate ? e._delegate : e
                }
            },
            4311: function (e, t, n) {
                n.d(t, {
                    Mz: function () {
                        return c
                    },
                    V: function () {
                        return l
                    },
                    Wn: function () {
                        return u
                    }
                });
                var r = n(4316)
                    , i = n(4742)
                    , s = n(4781);
                let o, a;

                function c(e) {
                    return o || (o = (0,
                        r.ZF)(e)),
                        o
                }

                function u(e) {
                    if (o && (0,
                        i.v0)(o)?.currentUser)
                        return !0;
                    (0,
                        s.jsonFetch)(e, {
                        method: "POST",
                        credentials: "include"
                    }).then((e => {
                            const {parsedBody: t} = e;
                            (0,
                                i._p)((0,
                                i.v0)(o), t.token)
                        }
                    ))
                }

                function l() {
                    return new Promise((e => {
                            if (a)
                                return void e(a);
                            const t = (0,
                                i.v0)(o);
                            (0,
                                i.Aj)(t, (t => {
                                    t ? (a = t,
                                        e(a)) : a = null
                                }
                            ))
                        }
                    ))
                }
            },
            5822: function (e, t, n) {
                var r = n.p + "static/annotations.caea444204.webp"
                    , i = n.p + "static/lesson-list.af3a89a1ca.webp"
                    , s = n.p + "static/summary.8f7a7a8385.webp"
                    , o = n.p + "static/bookmark.54854c193e.webp"
                    , a = n.p + "static/navigation.095b4831d8.webp"
                    , c = n.p + "static/chat.230f9d5b20.webp"
                    , u = n.p + "static/resources.d1da0ae360.webp"
                    , l = n.p + "static/settings.6c93656d25.webp"
                    , h = n.p + "static/notes.71bfbd664b.webp"
                    , d = n(4311)
                    , f = n(9904)
                    , p = n(1869)
                    , m = n(1711)
                    , g = n(6258);

                class v {
                    constructor(e) {
                        this.uid = e
                    }

                    isAuthenticated() {
                        return null != this.uid
                    }

                    toKey() {
                        return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user"
                    }

                    isEqual(e) {
                        return e.uid === this.uid
                    }
                }

                v.UNAUTHENTICATED = new v(null),
                    v.GOOGLE_CREDENTIALS = new v("google-credentials-uid"),
                    v.FIRST_PARTY = new v("first-party-uid"),
                    v.MOCK_USER = new v("mock-user");
                let y = "9.23.0";
                const w = new m.Yd("@firebase/firestore");

                function _(e, ...t) {
                    if (w.logLevel <= m.in.DEBUG) {
                        const n = t.map(T);
                        w.debug(`Firestore (${y}): ${e}`, ...n)
                    }
                }

                function b(e, ...t) {
                    if (w.logLevel <= m.in.ERROR) {
                        const n = t.map(T);
                        w.error(`Firestore (${y}): ${e}`, ...n)
                    }
                }

                function I(e, ...t) {
                    if (w.logLevel <= m.in.WARN) {
                        const n = t.map(T);
                        w.warn(`Firestore (${y}): ${e}`, ...n)
                    }
                }

                function T(e) {
                    if ("string" == typeof e)
                        return e;
                    try {
                        return t = e,
                            JSON.stringify(t)
                    } catch (t) {
                        return e
                    }
                    var t
                }

                function E(e = "Unexpected state") {
                    const t = `FIRESTORE (${y}) INTERNAL ASSERTION FAILED: ` + e;
                    throw b(t),
                        new Error(t)
                }

                function k(e, t) {
                    e || E()
                }

                function S(e, t) {
                    return e
                }

                const R = "cancelled"
                    , A = "unknown"
                    , O = "invalid-argument"
                    , C = "deadline-exceeded"
                    , P = "not-found"
                    , N = "permission-denied"
                    , D = "unauthenticated"
                    , L = "resource-exhausted"
                    , M = "failed-precondition"
                    , U = "aborted"
                    , x = "out-of-range"
                    , F = "unimplemented"
                    , V = "internal"
                    , j = "unavailable";

                class z extends g.ZR {
                    constructor(e, t) {
                        super(e, t),
                            this.code = e,
                            this.message = t,
                            this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`
                    }
                }

                class $ {
                    constructor(e, t) {
                        this.user = t,
                            this.type = "OAuth",
                            this.headers = new Map,
                            this.headers.set("Authorization", `Bearer ${e}`)
                    }
                }

                class B {
                    getToken() {
                        return Promise.resolve(null)
                    }

                    invalidateToken() {
                    }

                    start(e, t) {
                        e.enqueueRetryable((() => t(v.UNAUTHENTICATED)))
                    }

                    shutdown() {
                    }
                }

                class H {
                    constructor(e) {
                        this.token = e,
                            this.changeListener = null
                    }

                    getToken() {
                        return Promise.resolve(this.token)
                    }

                    invalidateToken() {
                    }

                    start(e, t) {
                        this.changeListener = t,
                            e.enqueueRetryable((() => t(this.token.user)))
                    }

                    shutdown() {
                        this.changeListener = null
                    }
                }

                class W {
                    constructor(e) {
                        this.auth = null,
                            e.onInit((e => {
                                    this.auth = e
                                }
                            ))
                    }

                    getToken() {
                        return this.auth ? this.auth.getToken().then((e => e ? (k("string" == typeof e.accessToken),
                            new $(e.accessToken, new v(this.auth.getUid()))) : null)) : Promise.resolve(null)
                    }

                    invalidateToken() {
                    }

                    start(e, t) {
                    }

                    shutdown() {
                    }
                }

                class q {
                    constructor(e, t, n) {
                        this.t = e,
                            this.i = t,
                            this.o = n,
                            this.type = "FirstParty",
                            this.user = v.FIRST_PARTY,
                            this.u = new Map
                    }

                    h() {
                        return this.o ? this.o() : null
                    }

                    get headers() {
                        this.u.set("X-Goog-AuthUser", this.t);
                        const e = this.h();
                        return e && this.u.set("Authorization", e),
                        this.i && this.u.set("X-Goog-Iam-Authorization-Token", this.i),
                            this.u
                    }
                }

                class K {
                    constructor(e, t, n) {
                        this.t = e,
                            this.i = t,
                            this.o = n
                    }

                    getToken() {
                        return Promise.resolve(new q(this.t, this.i, this.o))
                    }

                    start(e, t) {
                        e.enqueueRetryable((() => t(v.FIRST_PARTY)))
                    }

                    shutdown() {
                    }

                    invalidateToken() {
                    }
                }

                class J {
                    constructor(e) {
                        this.value = e,
                            this.type = "AppCheck",
                            this.headers = new Map,
                        e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value)
                    }
                }

                class G {
                    constructor(e) {
                        this.l = e,
                            this.appCheck = null,
                            e.onInit((e => {
                                    this.appCheck = e
                                }
                            ))
                    }

                    getToken() {
                        return this.appCheck ? this.appCheck.getToken().then((e => e ? (k("string" == typeof e.token),
                            new J(e.token)) : null)) : Promise.resolve(null)
                    }

                    invalidateToken() {
                    }

                    start(e, t) {
                    }

                    shutdown() {
                    }
                }

                class X {
                    constructor(e, t, n, r, i, s, o, a, c) {
                        this.databaseId = e,
                            this.appId = t,
                            this.persistenceKey = n,
                            this.host = r,
                            this.ssl = i,
                            this.forceLongPolling = s,
                            this.autoDetectLongPolling = o,
                            this.longPollingOptions = a,
                            this.useFetchStreams = c
                    }
                }

                class Y {
                    constructor(e, t) {
                        this.projectId = e,
                            this.database = t || "(default)"
                    }

                    static empty() {
                        return new Y("", "")
                    }

                    get isDefaultDatabase() {
                        return "(default)" === this.database
                    }

                    isEqual(e) {
                        return e instanceof Y && e.projectId === this.projectId && e.database === this.database
                    }
                }

                class Q {
                    constructor(e, t, n) {
                        void 0 === t ? t = 0 : t > e.length && E(),
                            void 0 === n ? n = e.length - t : n > e.length - t && E(),
                            this.segments = e,
                            this.offset = t,
                            this.len = n
                    }

                    get length() {
                        return this.len
                    }

                    isEqual(e) {
                        return 0 === Q.comparator(this, e)
                    }

                    child(e) {
                        const t = this.segments.slice(this.offset, this.limit());
                        return e instanceof Q ? e.forEach((e => {
                                t.push(e)
                            }
                        )) : t.push(e),
                            this.construct(t)
                    }

                    limit() {
                        return this.offset + this.length
                    }

                    popFirst(e) {
                        return e = void 0 === e ? 1 : e,
                            this.construct(this.segments, this.offset + e, this.length - e)
                    }

                    popLast() {
                        return this.construct(this.segments, this.offset, this.length - 1)
                    }

                    firstSegment() {
                        return this.segments[this.offset]
                    }

                    lastSegment() {
                        return this.get(this.length - 1)
                    }

                    get(e) {
                        return this.segments[this.offset + e]
                    }

                    isEmpty() {
                        return 0 === this.length
                    }

                    isPrefixOf(e) {
                        if (e.length < this.length)
                            return !1;
                        for (let t = 0; t < this.length; t++)
                            if (this.get(t) !== e.get(t))
                                return !1;
                        return !0
                    }

                    isImmediateParentOf(e) {
                        if (this.length + 1 !== e.length)
                            return !1;
                        for (let t = 0; t < this.length; t++)
                            if (this.get(t) !== e.get(t))
                                return !1;
                        return !0
                    }

                    forEach(e) {
                        for (let t = this.offset, n = this.limit(); t < n; t++)
                            e(this.segments[t])
                    }

                    toArray() {
                        return this.segments.slice(this.offset, this.limit())
                    }

                    static comparator(e, t) {
                        const n = Math.min(e.length, t.length);
                        for (let r = 0; r < n; r++) {
                            const n = e.get(r)
                                , i = t.get(r);
                            if (n < i)
                                return -1;
                            if (n > i)
                                return 1
                        }
                        return e.length < t.length ? -1 : e.length > t.length ? 1 : 0
                    }
                }

                class Z extends Q {
                    construct(e, t, n) {
                        return new Z(e, t, n)
                    }

                    canonicalString() {
                        return this.toArray().join("/")
                    }

                    toString() {
                        return this.canonicalString()
                    }

                    static fromString(...e) {
                        const t = [];
                        for (const n of e) {
                            if (n.indexOf("//") >= 0)
                                throw new z(O, `Invalid segment (${n}). Paths must not contain // in them.`);
                            t.push(...n.split("/").filter((e => e.length > 0)))
                        }
                        return new Z(t)
                    }

                    static emptyPath() {
                        return new Z([])
                    }
                }

                const ee = /^[_a-zA-Z][_a-zA-Z0-9]*$/;

                class te extends Q {
                    construct(e, t, n) {
                        return new te(e, t, n)
                    }

                    static isValidIdentifier(e) {
                        return ee.test(e)
                    }

                    canonicalString() {
                        return this.toArray().map((e => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"),
                        te.isValidIdentifier(e) || (e = "`" + e + "`"),
                            e))).join(".")
                    }

                    toString() {
                        return this.canonicalString()
                    }

                    isKeyField() {
                        return 1 === this.length && "__name__" === this.get(0)
                    }

                    static keyField() {
                        return new te(["__name__"])
                    }

                    static fromServerFormat(e) {
                        const t = [];
                        let n = ""
                            , r = 0;
                        const i = () => {
                                if (0 === n.length)
                                    throw new z(O, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
                                t.push(n),
                                    n = ""
                            }
                        ;
                        let s = !1;
                        for (; r < e.length;) {
                            const t = e[r];
                            if ("\\" === t) {
                                if (r + 1 === e.length)
                                    throw new z(O, "Path has trailing escape character: " + e);
                                const t = e[r + 1];
                                if ("\\" !== t && "." !== t && "`" !== t)
                                    throw new z(O, "Path has invalid escape sequence: " + e);
                                n += t,
                                    r += 2
                            } else
                                "`" === t ? (s = !s,
                                    r++) : "." !== t || s ? (n += t,
                                    r++) : (i(),
                                    r++)
                        }
                        if (i(),
                            s)
                            throw new z(O, "Unterminated ` in path: " + e);
                        return new te(t)
                    }

                    static emptyPath() {
                        return new te([])
                    }
                }

                class ne {
                    constructor(e) {
                        this.path = e
                    }

                    static fromPath(e) {
                        return new ne(Z.fromString(e))
                    }

                    static fromName(e) {
                        return new ne(Z.fromString(e).popFirst(5))
                    }

                    static empty() {
                        return new ne(Z.emptyPath())
                    }

                    get collectionGroup() {
                        return this.path.popLast().lastSegment()
                    }

                    hasCollectionId(e) {
                        return this.path.length >= 2 && this.path.get(this.path.length - 2) === e
                    }

                    getCollectionGroup() {
                        return this.path.get(this.path.length - 2)
                    }

                    getCollectionPath() {
                        return this.path.popLast()
                    }

                    isEqual(e) {
                        return null !== e && 0 === Z.comparator(this.path, e.path)
                    }

                    toString() {
                        return this.path.toString()
                    }

                    static comparator(e, t) {
                        return Z.comparator(e.path, t.path)
                    }

                    static isDocumentKey(e) {
                        return e.length % 2 == 0
                    }

                    static fromSegments(e) {
                        return new ne(new Z(e.slice()))
                    }
                }

                function re(e, t, n) {
                    if (!n)
                        throw new z(O, `Function ${e}() cannot be called with an empty ${t}.`)
                }

                function ie(e) {
                    if (!ne.isDocumentKey(e))
                        throw new z(O, `Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`)
                }

                function se(e) {
                    if (ne.isDocumentKey(e))
                        throw new z(O, `Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`)
                }

                function oe(e) {
                    if (void 0 === e)
                        return "undefined";
                    if (null === e)
                        return "null";
                    if ("string" == typeof e)
                        return e.length > 20 && (e = `${e.substring(0, 20)}...`),
                            JSON.stringify(e);
                    if ("number" == typeof e || "boolean" == typeof e)
                        return "" + e;
                    if ("object" == typeof e) {
                        if (e instanceof Array)
                            return "an array";
                        {
                            const t = function (e) {
                                return e.constructor ? e.constructor.name : null
                            }(e);
                            return t ? `a custom ${t} object` : "an object"
                        }
                    }
                    return "function" == typeof e ? "a function" : E()
                }

                function ae(e, t) {
                    if ("_delegate" in e && (e = e._delegate),
                        !(e instanceof t)) {
                        if (t.name === e.constructor.name)
                            throw new z(O, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
                        {
                            const n = oe(e);
                            throw new z(O, `Expected type '${t.name}', but it was: ${n}`)
                        }
                    }
                    return e
                }

                function ce(e) {
                    const t = {};
                    return void 0 !== e.timeoutSeconds && (t.timeoutSeconds = e.timeoutSeconds),
                        t
                }

                let ue = null;

                function le(e) {
                    return 0 === e && 1 / e == -1 / 0
                }

                const he = {
                    BatchGetDocuments: "batchGet",
                    Commit: "commit",
                    RunQuery: "runQuery",
                    RunAggregationQuery: "runAggregationQuery"
                };
                var de, fe;

                function pe(e) {
                    if (void 0 === e)
                        return b("RPC_ERROR", "HTTP error has no status"),
                            A;
                    switch (e) {
                        case 200:
                            return "ok";
                        case 400:
                            return M;
                        case 401:
                            return D;
                        case 403:
                            return N;
                        case 404:
                            return P;
                        case 409:
                            return U;
                        case 416:
                            return x;
                        case 429:
                            return L;
                        case 499:
                            return R;
                        case 500:
                            return A;
                        case 501:
                            return F;
                        case 503:
                            return j;
                        case 504:
                            return C;
                        default:
                            return e >= 200 && e < 300 ? "ok" : e >= 400 && e < 500 ? M : e >= 500 && e < 600 ? V : A
                    }
                }

                (fe = de || (de = {}))[fe.OK = 0] = "OK",
                    fe[fe.CANCELLED = 1] = "CANCELLED",
                    fe[fe.UNKNOWN = 2] = "UNKNOWN",
                    fe[fe.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT",
                    fe[fe.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED",
                    fe[fe.NOT_FOUND = 5] = "NOT_FOUND",
                    fe[fe.ALREADY_EXISTS = 6] = "ALREADY_EXISTS",
                    fe[fe.PERMISSION_DENIED = 7] = "PERMISSION_DENIED",
                    fe[fe.UNAUTHENTICATED = 16] = "UNAUTHENTICATED",
                    fe[fe.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED",
                    fe[fe.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION",
                    fe[fe.ABORTED = 10] = "ABORTED",
                    fe[fe.OUT_OF_RANGE = 11] = "OUT_OF_RANGE",
                    fe[fe.UNIMPLEMENTED = 12] = "UNIMPLEMENTED",
                    fe[fe.INTERNAL = 13] = "INTERNAL",
                    fe[fe.UNAVAILABLE = 14] = "UNAVAILABLE",
                    fe[fe.DATA_LOSS = 15] = "DATA_LOSS";

                class me extends class {
                    constructor(e) {
                        this.databaseInfo = e,
                            this.databaseId = e.databaseId;
                        const t = e.ssl ? "https" : "http";
                        this.m = t + "://" + e.host,
                            this.p = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents"
                    }

                    get g() {
                        return !1
                    }

                    v(e, t, n, r, i) {
                        const s = (null === ue ? ue = 268435456 + Math.round(2147483648 * Math.random()) : ue++,
                        "0x" + ue.toString(16))
                            , o = this.I(e, t);
                        _("RestConnection", `Sending RPC '${e}' ${s}:`, o, n);
                        const a = {};
                        return this.T(a, r, i),
                            this.A(e, o, a, n).then((t => (_("RestConnection", `Received RPC '${e}' ${s}: `, t),
                                t)), (t => {
                                    throw I("RestConnection", `RPC '${e}' ${s} failed with error: `, t, "url: ", o, "request:", n),
                                        t
                                }
                            ))
                    }

                    R(e, t, n, r, i, s) {
                        return this.v(e, t, n, r, i)
                    }

                    T(e, t, n) {
                        e["X-Goog-Api-Client"] = "gl-js/ fire/" + y,
                            e["Content-Type"] = "text/plain",
                        this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId),
                        t && t.headers.forEach(((t, n) => e[n] = t)),
                        n && n.headers.forEach(((t, n) => e[n] = t))
                    }

                    I(e, t) {
                        const n = he[e];
                        return `${this.m}/v1/${t}:${n}`
                    }
                } {
                    constructor(e, t) {
                        super(e),
                            this.P = t
                    }

                    V(e, t) {
                        throw new Error("Not supported by FetchConnection")
                    }

                    async A(e, t, n, r) {
                        var i;
                        const s = JSON.stringify(r);
                        let o;
                        try {
                            o = await this.P(t, {
                                method: "POST",
                                headers: n,
                                body: s
                            })
                        } catch (e) {
                            const t = e;
                            throw new z(pe(t.status), "Request failed with error: " + t.statusText)
                        }
                        if (!o.ok) {
                            let e = await o.json();
                            Array.isArray(e) && (e = e[0]);
                            const t = null === (i = null == e ? void 0 : e.error) || void 0 === i ? void 0 : i.message;
                            throw new z(pe(o.status), `Request failed with error: ${null != t ? t : o.statusText}`)
                        }
                        return o.json()
                    }
                }

                function ge(e) {
                    const t = "undefined" != typeof self && (self.crypto || self.msCrypto)
                        , n = new Uint8Array(e);
                    if (t && "function" == typeof t.getRandomValues)
                        t.getRandomValues(n);
                    else
                        for (let t = 0; t < e; t++)
                            n[t] = Math.floor(256 * Math.random());
                    return n
                }

                class ve {
                    static N() {
                        const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
                            , t = 62 * Math.floor(256 / 62);
                        let n = "";
                        for (; n.length < 20;) {
                            const r = ge(40);
                            for (let i = 0; i < r.length; ++i)
                                n.length < 20 && r[i] < t && (n += e.charAt(r[i] % 62))
                        }
                        return n
                    }
                }

                function ye(e, t) {
                    return e < t ? -1 : e > t ? 1 : 0
                }

                function we(e, t, n) {
                    return e.length === t.length && e.every(((e, r) => n(e, t[r])))
                }

                function _e(e) {
                    let t = 0;
                    for (const n in e)
                        Object.prototype.hasOwnProperty.call(e, n) && t++;
                    return t
                }

                function be(e, t) {
                    for (const n in e)
                        Object.prototype.hasOwnProperty.call(e, n) && t(n, e[n])
                }

                class Ie extends Error {
                    constructor() {
                        super(...arguments),
                            this.name = "Base64DecodeError"
                    }
                }

                class Te {
                    constructor(e) {
                        this.binaryString = e
                    }

                    static fromBase64String(e) {
                        const t = function (e) {
                            try {
                                return atob(e)
                            } catch (e) {
                                throw "undefined" != typeof DOMException && e instanceof DOMException ? new Ie("Invalid base64 string: " + e) : e
                            }
                        }(e);
                        return new Te(t)
                    }

                    static fromUint8Array(e) {
                        const t = function (e) {
                            let t = "";
                            for (let n = 0; n < e.length; ++n)
                                t += String.fromCharCode(e[n]);
                            return t
                        }(e);
                        return new Te(t)
                    }

                    [Symbol.iterator]() {
                        let e = 0;
                        return {
                            next: () => e < this.binaryString.length ? {
                                value: this.binaryString.charCodeAt(e++),
                                done: !1
                            } : {
                                value: void 0,
                                done: !0
                            }
                        }
                    }

                    toBase64() {
                        return e = this.binaryString,
                            btoa(e);
                        var e
                    }

                    toUint8Array() {
                        return function (e) {
                            const t = new Uint8Array(e.length);
                            for (let n = 0; n < e.length; n++)
                                t[n] = e.charCodeAt(n);
                            return t
                        }(this.binaryString)
                    }

                    approximateByteSize() {
                        return 2 * this.binaryString.length
                    }

                    compareTo(e) {
                        return ye(this.binaryString, e.binaryString)
                    }

                    isEqual(e) {
                        return this.binaryString === e.binaryString
                    }
                }

                Te.EMPTY_BYTE_STRING = new Te("");
                const Ee = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);

                function ke(e) {
                    if (k(!!e),
                    "string" == typeof e) {
                        let t = 0;
                        const n = Ee.exec(e);
                        if (k(!!n),
                            n[1]) {
                            let e = n[1];
                            e = (e + "000000000").substr(0, 9),
                                t = Number(e)
                        }
                        const r = new Date(e);
                        return {
                            seconds: Math.floor(r.getTime() / 1e3),
                            nanos: t
                        }
                    }
                    return {
                        seconds: Se(e.seconds),
                        nanos: Se(e.nanos)
                    }
                }

                function Se(e) {
                    return "number" == typeof e ? e : "string" == typeof e ? Number(e) : 0
                }

                function Re(e) {
                    return "string" == typeof e ? Te.fromBase64String(e) : Te.fromUint8Array(e)
                }

                class Ae {
                    constructor(e, t) {
                        if (this.seconds = e,
                            this.nanoseconds = t,
                        t < 0)
                            throw new z(O, "Timestamp nanoseconds out of range: " + t);
                        if (t >= 1e9)
                            throw new z(O, "Timestamp nanoseconds out of range: " + t);
                        if (e < -62135596800)
                            throw new z(O, "Timestamp seconds out of range: " + e);
                        if (e >= 253402300800)
                            throw new z(O, "Timestamp seconds out of range: " + e)
                    }

                    static now() {
                        return Ae.fromMillis(Date.now())
                    }

                    static fromDate(e) {
                        return Ae.fromMillis(e.getTime())
                    }

                    static fromMillis(e) {
                        const t = Math.floor(e / 1e3)
                            , n = Math.floor(1e6 * (e - 1e3 * t));
                        return new Ae(t, n)
                    }

                    toDate() {
                        return new Date(this.toMillis())
                    }

                    toMillis() {
                        return 1e3 * this.seconds + this.nanoseconds / 1e6
                    }

                    _compareTo(e) {
                        return this.seconds === e.seconds ? ye(this.nanoseconds, e.nanoseconds) : ye(this.seconds, e.seconds)
                    }

                    isEqual(e) {
                        return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds
                    }

                    toString() {
                        return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")"
                    }

                    toJSON() {
                        return {
                            seconds: this.seconds,
                            nanoseconds: this.nanoseconds
                        }
                    }

                    valueOf() {
                        const e = this.seconds - -62135596800;
                        return String(e).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0")
                    }
                }

                function Oe(e) {
                    var t, n;
                    return "server_timestamp" === (null === (n = ((null === (t = null == e ? void 0 : e.mapValue) || void 0 === t ? void 0 : t.fields) || {}).__type__) || void 0 === n ? void 0 : n.stringValue)
                }

                function Ce(e) {
                    const t = e.mapValue.fields.__previous_value__;
                    return Oe(t) ? Ce(t) : t
                }

                function Pe(e) {
                    const t = ke(e.mapValue.fields.__local_write_time__.timestampValue);
                    return new Ae(t.seconds, t.nanos)
                }

                function Ne(e) {
                    return "nullValue" in e ? 0 : "booleanValue" in e ? 1 : "integerValue" in e || "doubleValue" in e ? 2 : "timestampValue" in e ? 3 : "stringValue" in e ? 5 : "bytesValue" in e ? 6 : "referenceValue" in e ? 7 : "geoPointValue" in e ? 8 : "arrayValue" in e ? 9 : "mapValue" in e ? Oe(e) ? 4 : function (e) {
                        return "__max__" === (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue
                    }(e) ? 9007199254740991 : 10 : E()
                }

                function De(e, t) {
                    if (e === t)
                        return !0;
                    const n = Ne(e);
                    if (n !== Ne(t))
                        return !1;
                    switch (n) {
                        case 0:
                        case 9007199254740991:
                            return !0;
                        case 1:
                            return e.booleanValue === t.booleanValue;
                        case 4:
                            return Pe(e).isEqual(Pe(t));
                        case 3:
                            return function (e, t) {
                                if ("string" == typeof e.timestampValue && "string" == typeof t.timestampValue && e.timestampValue.length === t.timestampValue.length)
                                    return e.timestampValue === t.timestampValue;
                                const n = ke(e.timestampValue)
                                    , r = ke(t.timestampValue);
                                return n.seconds === r.seconds && n.nanos === r.nanos
                            }(e, t);
                        case 5:
                            return e.stringValue === t.stringValue;
                        case 6:
                            return function (e, t) {
                                return Re(e.bytesValue).isEqual(Re(t.bytesValue))
                            }(e, t);
                        case 7:
                            return e.referenceValue === t.referenceValue;
                        case 8:
                            return function (e, t) {
                                return Se(e.geoPointValue.latitude) === Se(t.geoPointValue.latitude) && Se(e.geoPointValue.longitude) === Se(t.geoPointValue.longitude)
                            }(e, t);
                        case 2:
                            return function (e, t) {
                                if ("integerValue" in e && "integerValue" in t)
                                    return Se(e.integerValue) === Se(t.integerValue);
                                if ("doubleValue" in e && "doubleValue" in t) {
                                    const n = Se(e.doubleValue)
                                        , r = Se(t.doubleValue);
                                    return n === r ? le(n) === le(r) : isNaN(n) && isNaN(r)
                                }
                                return !1
                            }(e, t);
                        case 9:
                            return we(e.arrayValue.values || [], t.arrayValue.values || [], De);
                        case 10:
                            return function (e, t) {
                                const n = e.mapValue.fields || {}
                                    , r = t.mapValue.fields || {};
                                if (_e(n) !== _e(r))
                                    return !1;
                                for (const e in n)
                                    if (n.hasOwnProperty(e) && (void 0 === r[e] || !De(n[e], r[e])))
                                        return !1;
                                return !0
                            }(e, t);
                        default:
                            return E()
                    }
                }

                function Le(e) {
                    return !!e && "mapValue" in e
                }

                function Me(e) {
                    if (e.geoPointValue)
                        return {
                            geoPointValue: Object.assign({}, e.geoPointValue)
                        };
                    if (e.timestampValue && "object" == typeof e.timestampValue)
                        return {
                            timestampValue: Object.assign({}, e.timestampValue)
                        };
                    if (e.mapValue) {
                        const t = {
                            mapValue: {
                                fields: {}
                            }
                        };
                        return be(e.mapValue.fields, ((e, n) => t.mapValue.fields[e] = Me(n))),
                            t
                    }
                    if (e.arrayValue) {
                        const t = {
                            arrayValue: {
                                values: []
                            }
                        };
                        for (let n = 0; n < (e.arrayValue.values || []).length; ++n)
                            t.arrayValue.values[n] = Me(e.arrayValue.values[n]);
                        return t
                    }
                    return Object.assign({}, e)
                }

                class Ue {
                    constructor(e) {
                        this.timestamp = e
                    }

                    static fromTimestamp(e) {
                        return new Ue(e)
                    }

                    static min() {
                        return new Ue(new Ae(0, 0))
                    }

                    static max() {
                        return new Ue(new Ae(253402300799, 999999999))
                    }

                    compareTo(e) {
                        return this.timestamp._compareTo(e.timestamp)
                    }

                    isEqual(e) {
                        return this.timestamp.isEqual(e.timestamp)
                    }

                    toMicroseconds() {
                        return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3
                    }

                    toString() {
                        return "SnapshotVersion(" + this.timestamp.toString() + ")"
                    }

                    toTimestamp() {
                        return this.timestamp
                    }
                }

                class xe {
                    constructor(e, t) {
                        this.comparator = e,
                            this.root = t || Ve.EMPTY
                    }

                    insert(e, t) {
                        return new xe(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, Ve.BLACK, null, null))
                    }

                    remove(e) {
                        return new xe(this.comparator, this.root.remove(e, this.comparator).copy(null, null, Ve.BLACK, null, null))
                    }

                    get(e) {
                        let t = this.root;
                        for (; !t.isEmpty();) {
                            const n = this.comparator(e, t.key);
                            if (0 === n)
                                return t.value;
                            n < 0 ? t = t.left : n > 0 && (t = t.right)
                        }
                        return null
                    }

                    indexOf(e) {
                        let t = 0
                            , n = this.root;
                        for (; !n.isEmpty();) {
                            const r = this.comparator(e, n.key);
                            if (0 === r)
                                return t + n.left.size;
                            r < 0 ? n = n.left : (t += n.left.size + 1,
                                n = n.right)
                        }
                        return -1
                    }

                    isEmpty() {
                        return this.root.isEmpty()
                    }

                    get size() {
                        return this.root.size
                    }

                    minKey() {
                        return this.root.minKey()
                    }

                    maxKey() {
                        return this.root.maxKey()
                    }

                    inorderTraversal(e) {
                        return this.root.inorderTraversal(e)
                    }

                    forEach(e) {
                        this.inorderTraversal(((t, n) => (e(t, n),
                            !1)))
                    }

                    toString() {
                        const e = [];
                        return this.inorderTraversal(((t, n) => (e.push(`${t}:${n}`),
                            !1))),
                            `{${e.join(", ")}}`
                    }

                    reverseTraversal(e) {
                        return this.root.reverseTraversal(e)
                    }

                    getIterator() {
                        return new Fe(this.root, null, this.comparator, !1)
                    }

                    getIteratorFrom(e) {
                        return new Fe(this.root, e, this.comparator, !1)
                    }

                    getReverseIterator() {
                        return new Fe(this.root, null, this.comparator, !0)
                    }

                    getReverseIteratorFrom(e) {
                        return new Fe(this.root, e, this.comparator, !0)
                    }
                }

                class Fe {
                    constructor(e, t, n, r) {
                        this.isReverse = r,
                            this.nodeStack = [];
                        let i = 1;
                        for (; !e.isEmpty();)
                            if (i = t ? n(e.key, t) : 1,
                            t && r && (i *= -1),
                            i < 0)
                                e = this.isReverse ? e.left : e.right;
                            else {
                                if (0 === i) {
                                    this.nodeStack.push(e);
                                    break
                                }
                                this.nodeStack.push(e),
                                    e = this.isReverse ? e.right : e.left
                            }
                    }

                    getNext() {
                        let e = this.nodeStack.pop();
                        const t = {
                            key: e.key,
                            value: e.value
                        };
                        if (this.isReverse)
                            for (e = e.left; !e.isEmpty();)
                                this.nodeStack.push(e),
                                    e = e.right;
                        else
                            for (e = e.right; !e.isEmpty();)
                                this.nodeStack.push(e),
                                    e = e.left;
                        return t
                    }

                    hasNext() {
                        return this.nodeStack.length > 0
                    }

                    peek() {
                        if (0 === this.nodeStack.length)
                            return null;
                        const e = this.nodeStack[this.nodeStack.length - 1];
                        return {
                            key: e.key,
                            value: e.value
                        }
                    }
                }

                class Ve {
                    constructor(e, t, n, r, i) {
                        this.key = e,
                            this.value = t,
                            this.color = null != n ? n : Ve.RED,
                            this.left = null != r ? r : Ve.EMPTY,
                            this.right = null != i ? i : Ve.EMPTY,
                            this.size = this.left.size + 1 + this.right.size
                    }

                    copy(e, t, n, r, i) {
                        return new Ve(null != e ? e : this.key, null != t ? t : this.value, null != n ? n : this.color, null != r ? r : this.left, null != i ? i : this.right)
                    }

                    isEmpty() {
                        return !1
                    }

                    inorderTraversal(e) {
                        return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e)
                    }

                    reverseTraversal(e) {
                        return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e)
                    }

                    min() {
                        return this.left.isEmpty() ? this : this.left.min()
                    }

                    minKey() {
                        return this.min().key
                    }

                    maxKey() {
                        return this.right.isEmpty() ? this.key : this.right.maxKey()
                    }

                    insert(e, t, n) {
                        let r = this;
                        const i = n(e, r.key);
                        return r = i < 0 ? r.copy(null, null, null, r.left.insert(e, t, n), null) : 0 === i ? r.copy(null, t, null, null, null) : r.copy(null, null, null, null, r.right.insert(e, t, n)),
                            r.fixUp()
                    }

                    removeMin() {
                        if (this.left.isEmpty())
                            return Ve.EMPTY;
                        let e = this;
                        return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()),
                            e = e.copy(null, null, null, e.left.removeMin(), null),
                            e.fixUp()
                    }

                    remove(e, t) {
                        let n, r = this;
                        if (t(e, r.key) < 0)
                            r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()),
                                r = r.copy(null, null, null, r.left.remove(e, t), null);
                        else {
                            if (r.left.isRed() && (r = r.rotateRight()),
                            r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()),
                            0 === t(e, r.key)) {
                                if (r.right.isEmpty())
                                    return Ve.EMPTY;
                                n = r.right.min(),
                                    r = r.copy(n.key, n.value, null, null, r.right.removeMin())
                            }
                            r = r.copy(null, null, null, null, r.right.remove(e, t))
                        }
                        return r.fixUp()
                    }

                    isRed() {
                        return this.color
                    }

                    fixUp() {
                        let e = this;
                        return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()),
                        e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()),
                        e.left.isRed() && e.right.isRed() && (e = e.colorFlip()),
                            e
                    }

                    moveRedLeft() {
                        let e = this.colorFlip();
                        return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()),
                            e = e.rotateLeft(),
                            e = e.colorFlip()),
                            e
                    }

                    moveRedRight() {
                        let e = this.colorFlip();
                        return e.left.left.isRed() && (e = e.rotateRight(),
                            e = e.colorFlip()),
                            e
                    }

                    rotateLeft() {
                        const e = this.copy(null, null, Ve.RED, null, this.right.left);
                        return this.right.copy(null, null, this.color, e, null)
                    }

                    rotateRight() {
                        const e = this.copy(null, null, Ve.RED, this.left.right, null);
                        return this.left.copy(null, null, this.color, null, e)
                    }

                    colorFlip() {
                        const e = this.left.copy(null, null, !this.left.color, null, null)
                            , t = this.right.copy(null, null, !this.right.color, null, null);
                        return this.copy(null, null, !this.color, e, t)
                    }

                    checkMaxDepth() {
                        const e = this.check();
                        return Math.pow(2, e) <= this.size + 1
                    }

                    check() {
                        if (this.isRed() && this.left.isRed())
                            throw E();
                        if (this.right.isRed())
                            throw E();
                        const e = this.left.check();
                        if (e !== this.right.check())
                            throw E();
                        return e + (this.isRed() ? 0 : 1)
                    }
                }

                Ve.EMPTY = null,
                    Ve.RED = !0,
                    Ve.BLACK = !1,
                    Ve.EMPTY = new class {
                        constructor() {
                            this.size = 0
                        }

                        get key() {
                            throw E()
                        }

                        get value() {
                            throw E()
                        }

                        get color() {
                            throw E()
                        }

                        get left() {
                            throw E()
                        }

                        get right() {
                            throw E()
                        }

                        copy(e, t, n, r, i) {
                            return this
                        }

                        insert(e, t, n) {
                            return new Ve(e, t)
                        }

                        remove(e, t) {
                            return this
                        }

                        isEmpty() {
                            return !0
                        }

                        inorderTraversal(e) {
                            return !1
                        }

                        reverseTraversal(e) {
                            return !1
                        }

                        minKey() {
                            return null
                        }

                        maxKey() {
                            return null
                        }

                        isRed() {
                            return !1
                        }

                        checkMaxDepth() {
                            return !0
                        }

                        check() {
                            return 0
                        }
                    }
                ;

                class je {
                    constructor(e) {
                        this.comparator = e,
                            this.data = new xe(this.comparator)
                    }

                    has(e) {
                        return null !== this.data.get(e)
                    }

                    first() {
                        return this.data.minKey()
                    }

                    last() {
                        return this.data.maxKey()
                    }

                    get size() {
                        return this.data.size
                    }

                    indexOf(e) {
                        return this.data.indexOf(e)
                    }

                    forEach(e) {
                        this.data.inorderTraversal(((t, n) => (e(t),
                            !1)))
                    }

                    forEachInRange(e, t) {
                        const n = this.data.getIteratorFrom(e[0]);
                        for (; n.hasNext();) {
                            const r = n.getNext();
                            if (this.comparator(r.key, e[1]) >= 0)
                                return;
                            t(r.key)
                        }
                    }

                    forEachWhile(e, t) {
                        let n;
                        for (n = void 0 !== t ? this.data.getIteratorFrom(t) : this.data.getIterator(); n.hasNext();)
                            if (!e(n.getNext().key))
                                return
                    }

                    firstAfterOrEqual(e) {
                        const t = this.data.getIteratorFrom(e);
                        return t.hasNext() ? t.getNext().key : null
                    }

                    getIterator() {
                        return new ze(this.data.getIterator())
                    }

                    getIteratorFrom(e) {
                        return new ze(this.data.getIteratorFrom(e))
                    }

                    add(e) {
                        return this.copy(this.data.remove(e).insert(e, !0))
                    }

                    delete(e) {
                        return this.has(e) ? this.copy(this.data.remove(e)) : this
                    }

                    isEmpty() {
                        return this.data.isEmpty()
                    }

                    unionWith(e) {
                        let t = this;
                        return t.size < e.size && (t = e,
                            e = this),
                            e.forEach((e => {
                                    t = t.add(e)
                                }
                            )),
                            t
                    }

                    isEqual(e) {
                        if (!(e instanceof je))
                            return !1;
                        if (this.size !== e.size)
                            return !1;
                        const t = this.data.getIterator()
                            , n = e.data.getIterator();
                        for (; t.hasNext();) {
                            const e = t.getNext().key
                                , r = n.getNext().key;
                            if (0 !== this.comparator(e, r))
                                return !1
                        }
                        return !0
                    }

                    toArray() {
                        const e = [];
                        return this.forEach((t => {
                                e.push(t)
                            }
                        )),
                            e
                    }

                    toString() {
                        const e = [];
                        return this.forEach((t => e.push(t))),
                        "SortedSet(" + e.toString() + ")"
                    }

                    copy(e) {
                        const t = new je(this.comparator);
                        return t.data = e,
                            t
                    }
                }

                class ze {
                    constructor(e) {
                        this.iter = e
                    }

                    getNext() {
                        return this.iter.getNext().key
                    }

                    hasNext() {
                        return this.iter.hasNext()
                    }
                }

                class $e {
                    constructor(e) {
                        this.fields = e,
                            e.sort(te.comparator)
                    }

                    static empty() {
                        return new $e([])
                    }

                    unionWith(e) {
                        let t = new je(te.comparator);
                        for (const e of this.fields)
                            t = t.add(e);
                        for (const n of e)
                            t = t.add(n);
                        return new $e(t.toArray())
                    }

                    covers(e) {
                        for (const t of this.fields)
                            if (t.isPrefixOf(e))
                                return !0;
                        return !1
                    }

                    isEqual(e) {
                        return we(this.fields, e.fields, ((e, t) => e.isEqual(t)))
                    }
                }

                class Be {
                    constructor(e) {
                        this.value = e
                    }

                    static empty() {
                        return new Be({
                            mapValue: {}
                        })
                    }

                    field(e) {
                        if (e.isEmpty())
                            return this.value;
                        {
                            let t = this.value;
                            for (let n = 0; n < e.length - 1; ++n)
                                if (t = (t.mapValue.fields || {})[e.get(n)],
                                    !Le(t))
                                    return null;
                            return t = (t.mapValue.fields || {})[e.lastSegment()],
                            t || null
                        }
                    }

                    set(e, t) {
                        this.getFieldsMap(e.popLast())[e.lastSegment()] = Me(t)
                    }

                    setAll(e) {
                        let t = te.emptyPath()
                            , n = {}
                            , r = [];
                        e.forEach(((e, i) => {
                                if (!t.isImmediateParentOf(i)) {
                                    const e = this.getFieldsMap(t);
                                    this.applyChanges(e, n, r),
                                        n = {},
                                        r = [],
                                        t = i.popLast()
                                }
                                e ? n[i.lastSegment()] = Me(e) : r.push(i.lastSegment())
                            }
                        ));
                        const i = this.getFieldsMap(t);
                        this.applyChanges(i, n, r)
                    }

                    delete(e) {
                        const t = this.field(e.popLast());
                        Le(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()]
                    }

                    isEqual(e) {
                        return De(this.value, e.value)
                    }

                    getFieldsMap(e) {
                        let t = this.value;
                        t.mapValue.fields || (t.mapValue = {
                            fields: {}
                        });
                        for (let n = 0; n < e.length; ++n) {
                            let r = t.mapValue.fields[e.get(n)];
                            Le(r) && r.mapValue.fields || (r = {
                                mapValue: {
                                    fields: {}
                                }
                            },
                                t.mapValue.fields[e.get(n)] = r),
                                t = r
                        }
                        return t.mapValue.fields
                    }

                    applyChanges(e, t, n) {
                        be(t, ((t, n) => e[t] = n));
                        for (const t of n)
                            delete e[t]
                    }

                    clone() {
                        return new Be(Me(this.value))
                    }
                }

                class He {
                    constructor(e, t, n, r, i, s, o) {
                        this.key = e,
                            this.documentType = t,
                            this.version = n,
                            this.readTime = r,
                            this.createTime = i,
                            this.data = s,
                            this.documentState = o
                    }

                    static newInvalidDocument(e) {
                        return new He(e, 0, Ue.min(), Ue.min(), Ue.min(), Be.empty(), 0)
                    }

                    static newFoundDocument(e, t, n, r) {
                        return new He(e, 1, t, Ue.min(), n, r, 0)
                    }

                    static newNoDocument(e, t) {
                        return new He(e, 2, t, Ue.min(), Ue.min(), Be.empty(), 0)
                    }

                    static newUnknownDocument(e, t) {
                        return new He(e, 3, t, Ue.min(), Ue.min(), Be.empty(), 2)
                    }

                    convertToFoundDocument(e, t) {
                        return !this.createTime.isEqual(Ue.min()) || 2 !== this.documentType && 0 !== this.documentType || (this.createTime = e),
                            this.version = e,
                            this.documentType = 1,
                            this.data = t,
                            this.documentState = 0,
                            this
                    }

                    convertToNoDocument(e) {
                        return this.version = e,
                            this.documentType = 2,
                            this.data = Be.empty(),
                            this.documentState = 0,
                            this
                    }

                    convertToUnknownDocument(e) {
                        return this.version = e,
                            this.documentType = 3,
                            this.data = Be.empty(),
                            this.documentState = 2,
                            this
                    }

                    setHasCommittedMutations() {
                        return this.documentState = 2,
                            this
                    }

                    setHasLocalMutations() {
                        return this.documentState = 1,
                            this.version = Ue.min(),
                            this
                    }

                    setReadTime(e) {
                        return this.readTime = e,
                            this
                    }

                    get hasLocalMutations() {
                        return 1 === this.documentState
                    }

                    get hasCommittedMutations() {
                        return 2 === this.documentState
                    }

                    get hasPendingWrites() {
                        return this.hasLocalMutations || this.hasCommittedMutations
                    }

                    isValidDocument() {
                        return 0 !== this.documentType
                    }

                    isFoundDocument() {
                        return 1 === this.documentType
                    }

                    isNoDocument() {
                        return 2 === this.documentType
                    }

                    isUnknownDocument() {
                        return 3 === this.documentType
                    }

                    isEqual(e) {
                        return e instanceof He && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data)
                    }

                    mutableCopy() {
                        return new He(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState)
                    }

                    toString() {
                        return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`
                    }
                }

                class We {
                    constructor(e, t = null, n = [], r = [], i = null, s = "F", o = null, a = null) {
                        this.path = e,
                            this.collectionGroup = t,
                            this.explicitOrderBy = n,
                            this.filters = r,
                            this.limit = i,
                            this.limitType = s,
                            this.startAt = o,
                            this.endAt = a,
                            this.q = null,
                            this.O = null,
                            this.startAt,
                            this.endAt
                    }
                }

                function qe(e, t) {
                    return function (e) {
                        return "number" == typeof e && Number.isInteger(e) && !le(e) && e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER
                    }(t) ? function (e) {
                        return {
                            integerValue: "" + e
                        }
                    }(t) : function (e, t) {
                        if (e.useProto3Json) {
                            if (isNaN(t))
                                return {
                                    doubleValue: "NaN"
                                };
                            if (t === 1 / 0)
                                return {
                                    doubleValue: "Infinity"
                                };
                            if (t === -1 / 0)
                                return {
                                    doubleValue: "-Infinity"
                                }
                        }
                        return {
                            doubleValue: le(t) ? "-0" : t
                        }
                    }(e, t)
                }

                class Ke {
                    constructor() {
                        this._ = void 0
                    }
                }

                class Je extends Ke {
                }

                class Ge extends Ke {
                    constructor(e) {
                        super(),
                            this.elements = e
                    }
                }

                class Xe extends Ke {
                    constructor(e) {
                        super(),
                            this.elements = e
                    }
                }

                class Ye extends Ke {
                    constructor(e, t) {
                        super(),
                            this.serializer = e,
                            this.k = t
                    }
                }

                class Qe {
                    constructor(e, t) {
                        this.updateTime = e,
                            this.exists = t
                    }

                    static none() {
                        return new Qe
                    }

                    static exists(e) {
                        return new Qe(void 0, e)
                    }

                    static updateTime(e) {
                        return new Qe(e)
                    }

                    get isNone() {
                        return void 0 === this.updateTime && void 0 === this.exists
                    }

                    isEqual(e) {
                        return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime)
                    }
                }

                class Ze {
                }

                class et extends Ze {
                    constructor(e, t, n, r = []) {
                        super(),
                            this.key = e,
                            this.value = t,
                            this.precondition = n,
                            this.fieldTransforms = r,
                            this.type = 0
                    }

                    getFieldMask() {
                        return null
                    }
                }

                class tt extends Ze {
                    constructor(e, t, n, r, i = []) {
                        super(),
                            this.key = e,
                            this.data = t,
                            this.fieldMask = n,
                            this.precondition = r,
                            this.fieldTransforms = i,
                            this.type = 1
                    }

                    getFieldMask() {
                        return this.fieldMask
                    }
                }

                class nt extends Ze {
                    constructor(e, t) {
                        super(),
                            this.key = e,
                            this.precondition = t,
                            this.type = 2,
                            this.fieldTransforms = []
                    }

                    getFieldMask() {
                        return null
                    }
                }

                class rt extends Ze {
                    constructor(e, t) {
                        super(),
                            this.key = e,
                            this.precondition = t,
                            this.type = 3,
                            this.fieldTransforms = []
                    }

                    getFieldMask() {
                        return null
                    }
                }

                class it {
                    constructor(e, t) {
                        this.databaseId = e,
                            this.useProto3Json = t
                    }
                }

                function st(e, t) {
                    return e.useProto3Json ? `${new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + t.nanoseconds).slice(-9)}Z` : {
                        seconds: "" + t.seconds,
                        nanos: t.nanoseconds
                    }
                }

                function ot(e, t) {
                    return e.useProto3Json ? t.toBase64() : t.toUint8Array()
                }

                function at(e, t) {
                    return st(e, t.toTimestamp())
                }

                function ct(e) {
                    return k(!!e),
                        Ue.fromTimestamp(function (e) {
                            const t = ke(e);
                            return new Ae(t.seconds, t.nanos)
                        }(e))
                }

                function ut(e, t) {
                    return function (e) {
                        return new Z(["projects", e.projectId, "databases", e.database])
                    }(e).child("documents").child(t).canonicalString()
                }

                function lt(e, t) {
                    return ut(e.databaseId, t.path)
                }

                function ht(e, t) {
                    const n = function (e) {
                        const t = Z.fromString(e);
                        return k(mt(t)),
                            t
                    }(t);
                    if (n.get(1) !== e.databaseId.projectId)
                        throw new z(O, "Tried to deserialize key from different project: " + n.get(1) + " vs " + e.databaseId.projectId);
                    if (n.get(3) !== e.databaseId.database)
                        throw new z(O, "Tried to deserialize key from different database: " + n.get(3) + " vs " + e.databaseId.database);
                    return new ne((k((r = n).length > 4 && "documents" === r.get(4)),
                        r.popFirst(5)));
                    var r
                }

                function dt(e) {
                    return new Z(["projects", e.databaseId.projectId, "databases", e.databaseId.database]).canonicalString()
                }

                function ft(e, t, n) {
                    return {
                        name: lt(e, t),
                        fields: n.value.mapValue.fields
                    }
                }

                function pt(e) {
                    const t = [];
                    return e.fields.forEach((e => t.push(e.canonicalString()))),
                        {
                            fieldPaths: t
                        }
                }

                function mt(e) {
                    return e.length >= 4 && "projects" === e.get(0) && "databases" === e.get(2)
                }

                function gt(e) {
                    return new it(e, !0)
                }

                class vt extends class {
                } {
                    constructor(e, t, n, r) {
                        super(),
                            this.authCredentials = e,
                            this.appCheckCredentials = t,
                            this.connection = n,
                            this.serializer = r,
                            this.J = !1
                    }

                    X() {
                        if (this.J)
                            throw new z(M, "The client has already been terminated.")
                    }

                    v(e, t, n) {
                        return this.X(),
                            Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then((([r, i]) => this.connection.v(e, t, n, r, i))).catch((e => {
                                    throw "FirebaseError" === e.name ? (e.code === D && (this.authCredentials.invalidateToken(),
                                        this.appCheckCredentials.invalidateToken()),
                                        e) : new z(A, e.toString())
                                }
                            ))
                    }

                    R(e, t, n, r) {
                        return this.X(),
                            Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then((([i, s]) => this.connection.R(e, t, n, i, s, r))).catch((e => {
                                    throw "FirebaseError" === e.name ? (e.code === D && (this.authCredentials.invalidateToken(),
                                        this.appCheckCredentials.invalidateToken()),
                                        e) : new z(A, e.toString())
                                }
                            ))
                    }

                    terminate() {
                        this.J = !0
                    }
                }

                async function yt(e, t) {
                    const n = S(e)
                        , r = dt(n.serializer) + "/documents"
                        , i = {
                        writes: t.map((e => function (e, t) {
                            let n;
                            if (t instanceof et)
                                n = {
                                    update: ft(e, t.key, t.value)
                                };
                            else if (t instanceof nt)
                                n = {
                                    delete: lt(e, t.key)
                                };
                            else if (t instanceof tt)
                                n = {
                                    update: ft(e, t.key, t.data),
                                    updateMask: pt(t.fieldMask)
                                };
                            else {
                                if (!(t instanceof rt))
                                    return E();
                                n = {
                                    verify: lt(e, t.key)
                                }
                            }
                            return t.fieldTransforms.length > 0 && (n.updateTransforms = t.fieldTransforms.map((e => function (e, t) {
                                const n = t.transform;
                                if (n instanceof Je)
                                    return {
                                        fieldPath: t.field.canonicalString(),
                                        setToServerValue: "REQUEST_TIME"
                                    };
                                if (n instanceof Ge)
                                    return {
                                        fieldPath: t.field.canonicalString(),
                                        appendMissingElements: {
                                            values: n.elements
                                        }
                                    };
                                if (n instanceof Xe)
                                    return {
                                        fieldPath: t.field.canonicalString(),
                                        removeAllFromArray: {
                                            values: n.elements
                                        }
                                    };
                                if (n instanceof Ye)
                                    return {
                                        fieldPath: t.field.canonicalString(),
                                        increment: n.k
                                    };
                                throw E()
                            }(0, e)))),
                            t.precondition.isNone || (n.currentDocument = function (e, t) {
                                return void 0 !== t.updateTime ? {
                                    updateTime: at(e, t.updateTime)
                                } : void 0 !== t.exists ? {
                                    exists: t.exists
                                } : E()
                            }(e, t.precondition)),
                                n
                        }(n.serializer, e)))
                    };
                    await n.v("Commit", r, i)
                }

                async function wt(e, t) {
                    const n = S(e)
                        , r = dt(n.serializer) + "/documents"
                        , i = {
                        documents: t.map((e => lt(n.serializer, e)))
                    }
                        , s = await n.R("BatchGetDocuments", r, i, t.length)
                        , o = new Map;
                    s.forEach((e => {
                            const t = function (e, t) {
                                return "found" in t ? function (e, t) {
                                    k(!!t.found),
                                        t.found.name,
                                        t.found.updateTime;
                                    const n = ht(e, t.found.name)
                                        , r = ct(t.found.updateTime)
                                        , i = t.found.createTime ? ct(t.found.createTime) : Ue.min()
                                        , s = new Be({
                                        mapValue: {
                                            fields: t.found.fields
                                        }
                                    });
                                    return He.newFoundDocument(n, r, i, s)
                                }(e, t) : "missing" in t ? function (e, t) {
                                    k(!!t.missing),
                                        k(!!t.readTime);
                                    const n = ht(e, t.missing)
                                        , r = ct(t.readTime);
                                    return He.newNoDocument(n, r)
                                }(e, t) : E()
                            }(n.serializer, e);
                            o.set(t.key.toString(), t)
                        }
                    ));
                    const a = [];
                    return t.forEach((e => {
                            const t = o.get(e.toString());
                            k(!!t),
                                a.push(t)
                        }
                    )),
                        a
                }

                const _t = new Map;

                function bt(e) {
                    if (e._terminated)
                        throw new z(M, "The client has already been terminated.");
                    if (!_t.has(e)) {
                        _("ComponentProvider", "Initializing Datastore");
                        const s = function (e) {
                            return new me(e, fetch.bind(null))
                        }((t = e._databaseId,
                            n = e.app.options.appId || "",
                            r = e._persistenceKey,
                            i = e._freezeSettings(),
                            new X(t, n, r, i.host, i.ssl, i.experimentalForceLongPolling, i.experimentalAutoDetectLongPolling, ce(i.experimentalLongPollingOptions), i.useFetchStreams)))
                            , o = gt(e._databaseId)
                            , a = function (e, t, n, r) {
                            return new vt(e, t, n, r)
                        }(e._authCredentials, e._appCheckCredentials, s, o);
                        _t.set(e, a)
                    }
                    var t, n, r, i;
                    return _t.get(e)
                }

                class It {
                    constructor(e) {
                        var t, n;
                        if (void 0 === e.host) {
                            if (void 0 !== e.ssl)
                                throw new z(O, "Can't provide ssl option if host option is not set");
                            this.host = "firestore.googleapis.com",
                                this.ssl = !0
                        } else
                            this.host = e.host,
                                this.ssl = null === (t = e.ssl) || void 0 === t || t;
                        if (this.credentials = e.credentials,
                            this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties,
                            this.cache = e.localCache,
                        void 0 === e.cacheSizeBytes)
                            this.cacheSizeBytes = 41943040;
                        else {
                            if (-1 !== e.cacheSizeBytes && e.cacheSizeBytes < 1048576)
                                throw new z(O, "cacheSizeBytes must be at least 1048576");
                            this.cacheSizeBytes = e.cacheSizeBytes
                        }
                        !function (e, t, n, r) {
                            if (!0 === t && !0 === r)
                                throw new z(O, "experimentalForceLongPolling and experimentalAutoDetectLongPolling cannot be used together.")
                        }(0, e.experimentalForceLongPolling, 0, e.experimentalAutoDetectLongPolling),
                            this.experimentalForceLongPolling = !!e.experimentalForceLongPolling,
                            this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : void 0 === e.experimentalAutoDetectLongPolling ? this.experimentalAutoDetectLongPolling = !0 : this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling,
                            this.experimentalLongPollingOptions = ce(null !== (n = e.experimentalLongPollingOptions) && void 0 !== n ? n : {}),
                            function (e) {
                                if (void 0 !== e.timeoutSeconds) {
                                    if (isNaN(e.timeoutSeconds))
                                        throw new z(O, `invalid long polling timeout: ${e.timeoutSeconds} (must not be NaN)`);
                                    if (e.timeoutSeconds < 5)
                                        throw new z(O, `invalid long polling timeout: ${e.timeoutSeconds} (minimum allowed value is 5)`);
                                    if (e.timeoutSeconds > 30)
                                        throw new z(O, `invalid long polling timeout: ${e.timeoutSeconds} (maximum allowed value is 30)`)
                                }
                            }(this.experimentalLongPollingOptions),
                            this.useFetchStreams = !!e.useFetchStreams
                    }

                    isEqual(e) {
                        return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && (t = this.experimentalLongPollingOptions,
                            n = e.experimentalLongPollingOptions,
                        t.timeoutSeconds === n.timeoutSeconds) && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams;
                        var t, n
                    }
                }

                class Tt {
                    constructor(e, t, n, r) {
                        this._authCredentials = e,
                            this._appCheckCredentials = t,
                            this._databaseId = n,
                            this._app = r,
                            this.type = "firestore-lite",
                            this._persistenceKey = "(lite)",
                            this._settings = new It({}),
                            this._settingsFrozen = !1
                    }

                    get app() {
                        if (!this._app)
                            throw new z(M, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
                        return this._app
                    }

                    get _initialized() {
                        return this._settingsFrozen
                    }

                    get _terminated() {
                        return void 0 !== this._terminateTask
                    }

                    _setSettings(e) {
                        if (this._settingsFrozen)
                            throw new z(M, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
                        this._settings = new It(e),
                        void 0 !== e.credentials && (this._authCredentials = function (e) {
                            if (!e)
                                return new B;
                            switch (e.type) {
                                case "firstParty":
                                    return new K(e.sessionIndex || "0", e.iamToken || null, e.authTokenFactory || null);
                                case "provider":
                                    return e.client;
                                default:
                                    throw new z(O, "makeAuthCredentialsProvider failed due to invalid credential type")
                            }
                        }(e.credentials))
                    }

                    _getSettings() {
                        return this._settings
                    }

                    _freezeSettings() {
                        return this._settingsFrozen = !0,
                            this._settings
                    }

                    _delete() {
                        return this._terminateTask || (this._terminateTask = this._terminate()),
                            this._terminateTask
                    }

                    toJSON() {
                        return {
                            app: this._app,
                            databaseId: this._databaseId,
                            settings: this._settings
                        }
                    }

                    _terminate() {
                        return function (e) {
                            const t = _t.get(e);
                            t && (_("ComponentProvider", "Removing Datastore"),
                                _t.delete(e),
                                t.terminate())
                        }(this),
                            Promise.resolve()
                    }
                }

                class Et {
                    constructor(e, t, n) {
                        this.converter = t,
                            this._key = n,
                            this.type = "document",
                            this.firestore = e
                    }

                    get _path() {
                        return this._key.path
                    }

                    get id() {
                        return this._key.path.lastSegment()
                    }

                    get path() {
                        return this._key.path.canonicalString()
                    }

                    get parent() {
                        return new St(this.firestore, this.converter, this._key.path.popLast())
                    }

                    withConverter(e) {
                        return new Et(this.firestore, e, this._key)
                    }
                }

                class kt {
                    constructor(e, t, n) {
                        this.converter = t,
                            this._query = n,
                            this.type = "query",
                            this.firestore = e
                    }

                    withConverter(e) {
                        return new kt(this.firestore, e, this._query)
                    }
                }

                class St extends kt {
                    constructor(e, t, n) {
                        super(e, t, new We(n)),
                            this._path = n,
                            this.type = "collection"
                    }

                    get id() {
                        return this._query.path.lastSegment()
                    }

                    get path() {
                        return this._query.path.canonicalString()
                    }

                    get parent() {
                        const e = this._path.popLast();
                        return e.isEmpty() ? null : new Et(this.firestore, null, new ne(e))
                    }

                    withConverter(e) {
                        return new St(this.firestore, e, this._path)
                    }
                }

                function Rt(e, t, ...n) {
                    if (e = (0,
                        g.m9)(e),
                    1 === arguments.length && (t = ve.N()),
                        re("doc", "path", t),
                    e instanceof Tt) {
                        const r = Z.fromString(t, ...n);
                        return ie(r),
                            new Et(e, null, new ne(r))
                    }
                    {
                        if (!(e instanceof Et || e instanceof St))
                            throw new z(O, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
                        const r = e._path.child(Z.fromString(t, ...n));
                        return ie(r),
                            new Et(e.firestore, e instanceof St ? e.converter : null, new ne(r))
                    }
                }

                class At {
                    constructor(e) {
                        this._byteString = e
                    }

                    static fromBase64String(e) {
                        try {
                            return new At(Te.fromBase64String(e))
                        } catch (e) {
                            throw new z(O, "Failed to construct data from Base64 string: " + e)
                        }
                    }

                    static fromUint8Array(e) {
                        return new At(Te.fromUint8Array(e))
                    }

                    toBase64() {
                        return this._byteString.toBase64()
                    }

                    toUint8Array() {
                        return this._byteString.toUint8Array()
                    }

                    toString() {
                        return "Bytes(base64: " + this.toBase64() + ")"
                    }

                    isEqual(e) {
                        return this._byteString.isEqual(e._byteString)
                    }
                }

                class Ot {
                    constructor(...e) {
                        for (let t = 0; t < e.length; ++t)
                            if (0 === e[t].length)
                                throw new z(O, "Invalid field name at argument $(i + 1). Field names must not be empty.");
                        this._internalPath = new te(e)
                    }

                    isEqual(e) {
                        return this._internalPath.isEqual(e._internalPath)
                    }
                }

                class Ct {
                    constructor(e) {
                        this._methodName = e
                    }
                }

                class Pt {
                    constructor(e, t) {
                        if (!isFinite(e) || e < -90 || e > 90)
                            throw new z(O, "Latitude must be a number between -90 and 90, but was: " + e);
                        if (!isFinite(t) || t < -180 || t > 180)
                            throw new z(O, "Longitude must be a number between -180 and 180, but was: " + t);
                        this._lat = e,
                            this._long = t
                    }

                    get latitude() {
                        return this._lat
                    }

                    get longitude() {
                        return this._long
                    }

                    isEqual(e) {
                        return this._lat === e._lat && this._long === e._long
                    }

                    toJSON() {
                        return {
                            latitude: this._lat,
                            longitude: this._long
                        }
                    }

                    _compareTo(e) {
                        return ye(this._lat, e._lat) || ye(this._long, e._long)
                    }
                }

                const Nt = /^__.*__$/;

                class Dt {
                    constructor(e, t, n) {
                        this.data = e,
                            this.fieldMask = t,
                            this.fieldTransforms = n
                    }

                    toMutation(e, t) {
                        return null !== this.fieldMask ? new tt(e, this.data, this.fieldMask, t, this.fieldTransforms) : new et(e, this.data, t, this.fieldTransforms)
                    }
                }

                class Lt {
                    constructor(e, t, n) {
                        this.data = e,
                            this.fieldMask = t,
                            this.fieldTransforms = n
                    }

                    toMutation(e, t) {
                        return new tt(e, this.data, this.fieldMask, t, this.fieldTransforms)
                    }
                }

                function Mt(e) {
                    switch (e) {
                        case 0:
                        case 2:
                        case 1:
                            return !0;
                        case 3:
                        case 4:
                            return !1;
                        default:
                            throw E()
                    }
                }

                class Ut {
                    constructor(e, t, n, r, i, s) {
                        this.settings = e,
                            this.databaseId = t,
                            this.serializer = n,
                            this.ignoreUndefinedProperties = r,
                        void 0 === i && this.tt(),
                            this.fieldTransforms = i || [],
                            this.fieldMask = s || []
                    }

                    get path() {
                        return this.settings.path
                    }

                    get et() {
                        return this.settings.et
                    }

                    nt(e) {
                        return new Ut(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask)
                    }

                    rt(e) {
                        var t;
                        const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e)
                            , r = this.nt({
                            path: n,
                            st: !1
                        });
                        return r.it(e),
                            r
                    }

                    ot(e) {
                        var t;
                        const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e)
                            , r = this.nt({
                            path: n,
                            st: !1
                        });
                        return r.tt(),
                            r
                    }

                    ut(e) {
                        return this.nt({
                            path: void 0,
                            st: !0
                        })
                    }

                    ct(e) {
                        return Xt(e, this.settings.methodName, this.settings.ht || !1, this.path, this.settings.lt)
                    }

                    contains(e) {
                        return void 0 !== this.fieldMask.find((t => e.isPrefixOf(t))) || void 0 !== this.fieldTransforms.find((t => e.isPrefixOf(t.field)))
                    }

                    tt() {
                        if (this.path)
                            for (let e = 0; e < this.path.length; e++)
                                this.it(this.path.get(e))
                    }

                    it(e) {
                        if (0 === e.length)
                            throw this.ct("Document fields must not be empty");
                        if (Mt(this.et) && Nt.test(e))
                            throw this.ct('Document fields cannot begin and end with "__"')
                    }
                }

                class xt {
                    constructor(e, t, n) {
                        this.databaseId = e,
                            this.ignoreUndefinedProperties = t,
                            this.serializer = n || gt(e)
                    }

                    ft(e, t, n, r = !1) {
                        return new Ut({
                            et: e,
                            methodName: t,
                            lt: n,
                            path: te.emptyPath(),
                            st: !1,
                            ht: r
                        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties)
                    }
                }

                function Ft(e) {
                    const t = e._freezeSettings()
                        , n = gt(e._databaseId);
                    return new xt(e._databaseId, !!t.ignoreUndefinedProperties, n)
                }

                function Vt(e, t, n, r, i, s = {}) {
                    const o = e.ft(s.merge || s.mergeFields ? 2 : 0, t, n, i);
                    qt("Data must be an object, but it was:", o, r);
                    const a = Ht(r, o);
                    let c, u;
                    if (s.merge)
                        c = new $e(o.fieldMask),
                            u = o.fieldTransforms;
                    else if (s.mergeFields) {
                        const e = [];
                        for (const r of s.mergeFields) {
                            const i = Kt(t, r, n);
                            if (!o.contains(i))
                                throw new z(O, `Field '${i}' is specified in your field mask but missing from your input data.`);
                            Yt(e, i) || e.push(i)
                        }
                        c = new $e(e),
                            u = o.fieldTransforms.filter((e => c.covers(e.field)))
                    } else
                        c = null,
                            u = o.fieldTransforms;
                    return new Dt(new Be(a), c, u)
                }

                class jt extends Ct {
                    _toFieldTransform(e) {
                        if (2 !== e.et)
                            throw 1 === e.et ? e.ct(`${this._methodName}() can only appear at the top level of your update data`) : e.ct(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
                        return e.fieldMask.push(e.path),
                            null
                    }

                    isEqual(e) {
                        return e instanceof jt
                    }
                }

                function zt(e, t, n, r) {
                    const i = e.ft(1, t, n);
                    qt("Data must be an object, but it was:", i, r);
                    const s = []
                        , o = Be.empty();
                    be(r, ((e, r) => {
                            const a = Gt(t, e, n);
                            r = (0,
                                g.m9)(r);
                            const c = i.ot(a);
                            if (r instanceof jt)
                                s.push(a);
                            else {
                                const e = Bt(r, c);
                                null != e && (s.push(a),
                                    o.set(a, e))
                            }
                        }
                    ));
                    const a = new $e(s);
                    return new Lt(o, a, i.fieldTransforms)
                }

                function $t(e, t, n, r, i, s) {
                    const o = e.ft(1, t, n)
                        , a = [Kt(t, r, n)]
                        , c = [i];
                    if (s.length % 2 != 0)
                        throw new z(O, `Function ${t}() needs to be called with an even number of arguments that alternate between field names and values.`);
                    for (let e = 0; e < s.length; e += 2)
                        a.push(Kt(t, s[e])),
                            c.push(s[e + 1]);
                    const u = []
                        , l = Be.empty();
                    for (let e = a.length - 1; e >= 0; --e)
                        if (!Yt(u, a[e])) {
                            const t = a[e];
                            let n = c[e];
                            n = (0,
                                g.m9)(n);
                            const r = o.ot(t);
                            if (n instanceof jt)
                                u.push(t);
                            else {
                                const e = Bt(n, r);
                                null != e && (u.push(t),
                                    l.set(t, e))
                            }
                        }
                    const h = new $e(u);
                    return new Lt(l, h, o.fieldTransforms)
                }

                function Bt(e, t) {
                    if (Wt(e = (0,
                        g.m9)(e)))
                        return qt("Unsupported field value:", t, e),
                            Ht(e, t);
                    if (e instanceof Ct)
                        return function (e, t) {
                            if (!Mt(t.et))
                                throw t.ct(`${e._methodName}() can only be used with update() and set()`);
                            if (!t.path)
                                throw t.ct(`${e._methodName}() is not currently supported inside arrays`);
                            const n = e._toFieldTransform(t);
                            n && t.fieldTransforms.push(n)
                        }(e, t),
                            null;
                    if (void 0 === e && t.ignoreUndefinedProperties)
                        return null;
                    if (t.path && t.fieldMask.push(t.path),
                    e instanceof Array) {
                        if (t.settings.st && 4 !== t.et)
                            throw t.ct("Nested arrays are not supported");
                        return function (e, t) {
                            const n = [];
                            let r = 0;
                            for (const i of e) {
                                let e = Bt(i, t.ut(r));
                                null == e && (e = {
                                    nullValue: "NULL_VALUE"
                                }),
                                    n.push(e),
                                    r++
                            }
                            return {
                                arrayValue: {
                                    values: n
                                }
                            }
                        }(e, t)
                    }
                    return function (e, t) {
                        if (null === (e = (0,
                            g.m9)(e)))
                            return {
                                nullValue: "NULL_VALUE"
                            };
                        if ("number" == typeof e)
                            return qe(t.serializer, e);
                        if ("boolean" == typeof e)
                            return {
                                booleanValue: e
                            };
                        if ("string" == typeof e)
                            return {
                                stringValue: e
                            };
                        if (e instanceof Date) {
                            const n = Ae.fromDate(e);
                            return {
                                timestampValue: st(t.serializer, n)
                            }
                        }
                        if (e instanceof Ae) {
                            const n = new Ae(e.seconds, 1e3 * Math.floor(e.nanoseconds / 1e3));
                            return {
                                timestampValue: st(t.serializer, n)
                            }
                        }
                        if (e instanceof Pt)
                            return {
                                geoPointValue: {
                                    latitude: e.latitude,
                                    longitude: e.longitude
                                }
                            };
                        if (e instanceof At)
                            return {
                                bytesValue: ot(t.serializer, e._byteString)
                            };
                        if (e instanceof Et) {
                            const n = t.databaseId
                                , r = e.firestore._databaseId;
                            if (!r.isEqual(n))
                                throw t.ct(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${n.projectId}/${n.database}`);
                            return {
                                referenceValue: ut(e.firestore._databaseId || t.databaseId, e._key.path)
                            }
                        }
                        throw t.ct(`Unsupported field value: ${oe(e)}`)
                    }(e, t)
                }

                function Ht(e, t) {
                    const n = {};
                    return function (e) {
                        for (const t in e)
                            if (Object.prototype.hasOwnProperty.call(e, t))
                                return !1;
                        return !0
                    }(e) ? t.path && t.path.length > 0 && t.fieldMask.push(t.path) : be(e, ((e, r) => {
                            const i = Bt(r, t.rt(e));
                            null != i && (n[e] = i)
                        }
                    )),
                        {
                            mapValue: {
                                fields: n
                            }
                        }
                }

                function Wt(e) {
                    return !("object" != typeof e || null === e || e instanceof Array || e instanceof Date || e instanceof Ae || e instanceof Pt || e instanceof At || e instanceof Et || e instanceof Ct)
                }

                function qt(e, t, n) {
                    if (!Wt(n) || !function (e) {
                        return "object" == typeof e && null !== e && (Object.getPrototypeOf(e) === Object.prototype || null === Object.getPrototypeOf(e))
                    }(n)) {
                        const r = oe(n);
                        throw "an object" === r ? t.ct(e + " a custom object") : t.ct(e + " " + r)
                    }
                }

                function Kt(e, t, n) {
                    if ((t = (0,
                        g.m9)(t)) instanceof Ot)
                        return t._internalPath;
                    if ("string" == typeof t)
                        return Gt(e, t);
                    throw Xt("Field path arguments must be of type string or ", e, !1, void 0, n)
                }

                const Jt = new RegExp("[~\\*/\\[\\]]");

                function Gt(e, t, n) {
                    if (t.search(Jt) >= 0)
                        throw Xt(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`, e, !1, void 0, n);
                    try {
                        return new Ot(...t.split("."))._internalPath
                    } catch (r) {
                        throw Xt(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, e, !1, void 0, n)
                    }
                }

                function Xt(e, t, n, r, i) {
                    const s = r && !r.isEmpty()
                        , o = void 0 !== i;
                    let a = `Function ${t}() called with invalid data`;
                    n && (a += " (via `toFirestore()`)"),
                        a += ". ";
                    let c = "";
                    return (s || o) && (c += " (found",
                    s && (c += ` in field ${r}`),
                    o && (c += ` in document ${i}`),
                        c += ")"),
                        new z(O, a + e + c)
                }

                function Yt(e, t) {
                    return e.some((e => e.isEqual(t)))
                }

                class Qt {
                    constructor(e, t, n, r, i) {
                        this._firestore = e,
                            this._userDataWriter = t,
                            this._key = n,
                            this._document = r,
                            this._converter = i
                    }

                    get id() {
                        return this._key.path.lastSegment()
                    }

                    get ref() {
                        return new Et(this._firestore, this._converter, this._key)
                    }

                    exists() {
                        return null !== this._document
                    }

                    data() {
                        if (this._document) {
                            if (this._converter) {
                                const e = new Zt(this._firestore, this._userDataWriter, this._key, this._document, null);
                                return this._converter.fromFirestore(e)
                            }
                            return this._userDataWriter.convertValue(this._document.data.value)
                        }
                    }

                    get(e) {
                        if (this._document) {
                            const t = this._document.data.field(en("DocumentSnapshot.get", e));
                            if (null !== t)
                                return this._userDataWriter.convertValue(t)
                        }
                    }
                }

                class Zt extends Qt {
                    data() {
                        return super.data()
                    }
                }

                function en(e, t) {
                    return "string" == typeof t ? Gt(e, t) : t instanceof Ot ? t._internalPath : t._delegate._internalPath
                }

                function tn(e, t, n) {
                    let r;
                    return r = e ? n && (n.merge || n.mergeFields) ? e.toFirestore(t, n) : e.toFirestore(t) : t,
                        r
                }

                class nn extends class {
                    convertValue(e, t = "none") {
                        switch (Ne(e)) {
                            case 0:
                                return null;
                            case 1:
                                return e.booleanValue;
                            case 2:
                                return Se(e.integerValue || e.doubleValue);
                            case 3:
                                return this.convertTimestamp(e.timestampValue);
                            case 4:
                                return this.convertServerTimestamp(e, t);
                            case 5:
                                return e.stringValue;
                            case 6:
                                return this.convertBytes(Re(e.bytesValue));
                            case 7:
                                return this.convertReference(e.referenceValue);
                            case 8:
                                return this.convertGeoPoint(e.geoPointValue);
                            case 9:
                                return this.convertArray(e.arrayValue, t);
                            case 10:
                                return this.convertObject(e.mapValue, t);
                            default:
                                throw E()
                        }
                    }

                    convertObject(e, t) {
                        return this.convertObjectMap(e.fields, t)
                    }

                    convertObjectMap(e, t = "none") {
                        const n = {};
                        return be(e, ((e, r) => {
                                n[e] = this.convertValue(r, t)
                            }
                        )),
                            n
                    }

                    convertGeoPoint(e) {
                        return new Pt(Se(e.latitude), Se(e.longitude))
                    }

                    convertArray(e, t) {
                        return (e.values || []).map((e => this.convertValue(e, t)))
                    }

                    convertServerTimestamp(e, t) {
                        switch (t) {
                            case "previous":
                                const n = Ce(e);
                                return null == n ? null : this.convertValue(n, t);
                            case "estimate":
                                return this.convertTimestamp(Pe(e));
                            default:
                                return null
                        }
                    }

                    convertTimestamp(e) {
                        const t = ke(e);
                        return new Ae(t.seconds, t.nanos)
                    }

                    convertDocumentKey(e, t) {
                        const n = Z.fromString(e);
                        k(mt(n));
                        const r = new Y(n.get(1), n.get(3))
                            , i = new ne(n.popFirst(5));
                        return r.isEqual(t) || b(`Document ${i} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`),
                            i
                    }
                } {
                    constructor(e) {
                        super(),
                            this.firestore = e
                    }

                    convertBytes(e) {
                        return new At(e)
                    }

                    convertReference(e) {
                        const t = this.convertDocumentKey(e, this.firestore._databaseId);
                        return new Et(this.firestore, null, t)
                    }
                }

                var rn;
                let sn, on;
                rn = `${f.Jn}_lite`,
                    y = rn,
                    (0,
                        f.Xd)(new p.wA("firestore/lite", ((e, {instanceIdentifier: t, options: n}) => {
                            const r = e.getProvider("app").getImmediate()
                                ,
                                i = new Tt(new W(e.getProvider("auth-internal")), new G(e.getProvider("app-check-internal")), function (e, t) {
                                    if (!Object.prototype.hasOwnProperty.apply(e.options, ["projectId"]))
                                        throw new z(O, '"projectId" not provided in firebase.initializeApp.');
                                    return new Y(e.options.projectId, t)
                                }(r, t), r);
                            return n && i._setSettings(n),
                                i
                        }
                    ), "PUBLIC").setMultipleInstances(!0)),
                    (0,
                        f.KN)("firestore-lite", "3.13.0", ""),
                    (0,
                        f.KN)("firestore-lite", "3.13.0", "esm2017");
                const an = document.querySelector("video")
                    , cn = window._bs.courseSlug
                    , un = window.location.pathname.split("/").filter((e => !!e))[0];
                if (window._bs.courseQuiz) {
                    const e = function (e, t) {
                        const n = "object" == typeof e ? e : (0,
                            f.Mq)()
                            , r = "string" == typeof e ? e : t || "(default)"
                            , i = (0,
                            f.qX)(n, "firestore/lite").getImmediate({
                            identifier: r
                        });
                        if (!i._initialized) {
                            const e = (0,
                                g.P0)("firestore");
                            e && function (e, t, n, r = {}) {
                                var i;
                                const s = (e = ae(e, Tt))._getSettings()
                                    , o = `${t}:${n}`;
                                if ("firestore.googleapis.com" !== s.host && s.host !== o && I("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."),
                                    e._setSettings(Object.assign(Object.assign({}, s), {
                                        host: o,
                                        ssl: !1
                                    })),
                                    r.mockUserToken) {
                                    let t, n;
                                    if ("string" == typeof r.mockUserToken)
                                        t = r.mockUserToken,
                                            n = v.MOCK_USER;
                                    else {
                                        t = (0,
                                            g.Sg)(r.mockUserToken, null === (i = e._app) || void 0 === i ? void 0 : i.options.projectId);
                                        const s = r.mockUserToken.sub || r.mockUserToken.user_id;
                                        if (!s)
                                            throw new z(O, "mockUserToken must contain 'sub' or 'user_id' field!");
                                        n = new v(s)
                                    }
                                    e._authCredentials = new H(new $(t, n))
                                }
                            }(i, ...e)
                        }
                        return i
                    }((0,
                        d.Mz)(window._bs.firebaseInit));
                    (0,
                        d.Wn)(`${window.location.origin}/courses/${cn}/token/`),
                        (0,
                            d.V)().then((t => {
                                sn = function (e, t, ...n) {
                                    if (e = (0,
                                        g.m9)(e),
                                        re("collection", "path", t),
                                    e instanceof Tt) {
                                        const r = Z.fromString(t, ...n);
                                        return se(r),
                                            new St(e, null, r)
                                    }
                                    {
                                        if (!(e instanceof Et || e instanceof St))
                                            throw new z(O, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
                                        const r = e._path.child(Z.fromString(t, ...n));
                                        return se(r),
                                            new St(e.firestore, null, r)
                                    }
                                }(e, `quizzes/${t.uid}/${cn}`)
                            }
                        ))
                }
                Promise.all([n.e(4202), n.e(4443), n.e(30), n.e(2759)]).then(n.bind(n, 30)).then((e => {
                        const t = new (0,
                            e.default)(an, {
                            assets: {
                                assetRoot: "https://api.frontendmasters.com/v1/kabuki/"
                            },
                            playerAssets: {
                                defaultThumbnail: "data:image/webp;base64,UklGRrIDAABXRUJQVlA4IKYDAACwFQCdASqgAFoAPtFaqFCoJKOipvO6uQAaCWlAfKVxiOR/5hP2THqW/8kBvQB4/Yr/OyWBwa+UzFz1Xgu/tw0n8QdKJEBJbrzAkYAANMyRW9fr9B06OFuo47umI3c3UY39zIPHPkNQOmNZoqMOMz6b8a3uqNNb4GyRSwYzaz+IxpMpIg1OSdTJ2dU0FzvngFeubAg3Fln98B8DEhmshU61SRNbOFwaKICWBjaqtV9v01viJHWMAAD+5ko4VdyBZI8apXSvsJF+W7kEdCI/5WAva7wy9Ucd7YwfTdna5rFElosgT6Q0WuZghHzGCyHYYtuqYKsB6huK4XscaSghaql7BIjOUMpmLmNaUjSNxSSTuWK3d8bJTf58IhCd/oqaLA2DGXsXMJtgUHnE4c4Ht22ciDKEEweROxUe6Lc+KtGrFw7JfyR5ReMABuYJ0urZ7/8eg+pbnUvfCBoBCk9q7Bs8h8DXcuWJS3KKIrd5R46k+o9RhI0AS2aSUfhE0CTWIanOpEpi3XlXu3DbUSb2vqOgk594eTVk3IkyQvUoFsMEUwMTn8iHdpUwnamp7wXMdAjXarCkyrdYzi/FQdqVuFio22bJmRIqNoRZt4KCVA7DqfyHonMn56QCGl/IRN/hDxaqa+Nnv7ZLO0/QR/NeC8KGouiL94OfpHSzvSLk6EhBnobFexWw1muqSbdWp+vYJaKotfcTCNM+ROGVpHEr2AaQvpieE3WqJbUZo1CoVnQ8z+Egdq0iouXUt0heiDTSCwfI1k3NTxoTlQxy7ZqmkTRPV3jeuKhxjB+7oyJXJRMaHIgLk6o5kOXkOOHg6Yls2MwjU9+f4LkaC/HZFFLQjQxaT+/L5/3VCWuKt2pvgZ3LqotA5Ff4Q4f/wKJPzHVLCPBYxlUtEtXF+EgbJWKhyg5fWsjl4u4dEt0raMAr+w022gbv+W+uWUhVu92+KkGMJEeUv+4YcUqTuGhQdG8uGityh2VaJana76XxJTNol0X8HPAzb6Jwkl+1AS1Rloo2Fx0zscTs4J2lnWwxxdO+TOxKFXYC9YdGxLct9t1GByBosWy+Dof+RrpuU72gevCOpt31f57ikruUhF3OiFNWd1aEgpoa+Fhy3jUeW5Apx7sIR/S1FTZooxBim6F0d/CwlmIRnbfVySbmucHb/sMJ76Br3Ll17t0oJvh5FLLrxPE8lo4TYq+HERJO9W5H7ouwJytP3dhfaSeXGotu6Uor7z0vHJj6MAAA",
                                annotations: r,
                                lessonList: i,
                                lessonSummary: s,
                                navBookmarkButton: o,
                                navBreadcrumb: a,
                                navFeedbackButton: c,
                                navResourcesButton: u,
                                navSettingsButton: l,
                                notes: h
                            },
                            playlist: {
                                routeRoot: `/${un}/${cn}/`
                            },
                            socialCTA: {
                                backLink: !0
                            },
                            courseQuiz: {
                                async getLessonQuizzes({lesson: e}) {
                                    if (!window._bs.courseQuiz || !window._bs.courseQuiz[e.slug])
                                        return;
                                    const t = window._bs.courseQuiz[e.slug];
                                    sn || await (0,
                                        d.V)(),
                                        on = Rt(sn, e.slug);
                                    const n = await function (e) {
                                        const t = bt((e = ae(e, Et)).firestore)
                                            , n = new nn(e.firestore);
                                        return wt(t, [e._key]).then((t => {
                                                k(1 === t.length);
                                                const r = t[0];
                                                return new Qt(e.firestore, n, e._key, r.isFoundDocument() ? r : null, e.converter)
                                            }
                                        ))
                                    }(on);
                                    if (n.exists()) {
                                        const e = await n.data();
                                        t.forEach(((t, n) => {
                                                var r;
                                                t.question.selected = "match" === t.question.type ? (r = e[n],
                                                    Array.isArray(r) ? r.map((e => e.split(","))) : r) : e[n]
                                            }
                                        ))
                                    } else
                                        !function (e, t, n) {
                                            const r = tn((e = ae(e, Et)).converter, t, n)
                                                , i = Vt(Ft(e.firestore), "setDoc", e._key, r, null !== e.converter, n);
                                            yt(bt(e.firestore), [i.toMutation(e._key, Qe.none())])
                                        }(on, {});
                                    return t
                                },
                                postAnswer({lesson: e, index: t, answer: n}) {
                                    const r = window._bs.courseQuiz[e.slug][t]
                                        , i = {};
                                    var s;
                                    i[t] = "match" === r.question.type ? (s = n,
                                        Array.isArray(s) ? s.map((e => e.join(","))) : s) : n,
                                        function (e, t, n, ...r) {
                                            const i = Ft((e = ae(e, Et)).firestore);
                                            let s;
                                            s = "string" == typeof (t = (0,
                                                g.m9)(t)) || t instanceof Ot ? $t(i, "updateDoc", e._key, t, n, r) : zt(i, "updateDoc", e._key, t),
                                                yt(bt(e.firestore), [s.toMutation(e._key, Qe.exists(!0))])
                                        }(on, i);
                                    const o = window._bs.courseQuiz[e.slug];
                                    return o[t].question.selected = n,
                                        o[t].correct
                                }
                            },
                            ui: {
                                logoLink: "/dashboard/",
                                showFeedback: window._bs.showFeedback
                            },
                            search: {
                                handler() {
                                    window.dispatchEvent(new CustomEvent("fm-global-search-open", {
                                        detail: {
                                            eventName: "course-player",
                                            course: {
                                                id: window._bs.courseHash
                                            }
                                        }
                                    }))
                                }
                            }
                        });
                        t.initCourse(cn),
                            t.initSession(cn),
                            window.addEventListener("fmplayer-refresh-route", (e => {
                                    t.route(e.detail.route),
                                        t.resumeFromSearchParams()
                                }
                            ))
                    }
                ))
            },
            9904: function (e, t, n) {
                n.d(t, {
                    Jn: function () {
                        return x
                    },
                    qX: function () {
                        return D
                    },
                    Xd: function () {
                        return N
                    },
                    Mq: function () {
                        return V
                    },
                    ZF: function () {
                        return F
                    },
                    KN: function () {
                        return j
                    }
                });
                var r = n(1869)
                    , i = n(1711)
                    , s = n(6258);
                const o = (e, t) => t.some((t => e instanceof t));
                let a, c;
                const u = new WeakMap
                    , l = new WeakMap
                    , h = new WeakMap
                    , d = new WeakMap
                    , f = new WeakMap;
                let p = {
                    get(e, t, n) {
                        if (e instanceof IDBTransaction) {
                            if ("done" === t)
                                return l.get(e);
                            if ("objectStoreNames" === t)
                                return e.objectStoreNames || h.get(e);
                            if ("store" === t)
                                return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0])
                        }
                        return v(e[t])
                    },
                    set(e, t, n) {
                        return e[t] = n,
                            !0
                    },
                    has(e, t) {
                        return e instanceof IDBTransaction && ("done" === t || "store" === t) || t in e
                    }
                };

                function m(e) {
                    return e !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? (c || (c = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])).includes(e) ? function (...t) {
                                return e.apply(y(this), t),
                                    v(u.get(this))
                            }
                            : function (...t) {
                                return v(e.apply(y(this), t))
                            }
                        : function (t, ...n) {
                            const r = e.call(y(this), t, ...n);
                            return h.set(r, t.sort ? t.sort() : [t]),
                                v(r)
                        }
                }

                function g(e) {
                    return "function" == typeof e ? m(e) : (e instanceof IDBTransaction && function (e) {
                        if (l.has(e))
                            return;
                        const t = new Promise(((t, n) => {
                                const r = () => {
                                        e.removeEventListener("complete", i),
                                            e.removeEventListener("error", s),
                                            e.removeEventListener("abort", s)
                                    }
                                    , i = () => {
                                        t(),
                                            r()
                                    }
                                    , s = () => {
                                        n(e.error || new DOMException("AbortError", "AbortError")),
                                            r()
                                    }
                                ;
                                e.addEventListener("complete", i),
                                    e.addEventListener("error", s),
                                    e.addEventListener("abort", s)
                            }
                        ));
                        l.set(e, t)
                    }(e),
                        o(e, a || (a = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])) ? new Proxy(e, p) : e)
                }

                function v(e) {
                    if (e instanceof IDBRequest)
                        return function (e) {
                            const t = new Promise(((t, n) => {
                                    const r = () => {
                                            e.removeEventListener("success", i),
                                                e.removeEventListener("error", s)
                                        }
                                        , i = () => {
                                            t(v(e.result)),
                                                r()
                                        }
                                        , s = () => {
                                            n(e.error),
                                                r()
                                        }
                                    ;
                                    e.addEventListener("success", i),
                                        e.addEventListener("error", s)
                                }
                            ));
                            return t.then((t => {
                                    t instanceof IDBCursor && u.set(t, e)
                                }
                            )).catch((() => {
                                }
                            )),
                                f.set(t, e),
                                t
                        }(e);
                    if (d.has(e))
                        return d.get(e);
                    const t = g(e);
                    return t !== e && (d.set(e, t),
                        f.set(t, e)),
                        t
                }

                const y = e => f.get(e);
                const w = ["get", "getKey", "getAll", "getAllKeys", "count"]
                    , _ = ["put", "add", "delete", "clear"]
                    , b = new Map;

                function I(e, t) {
                    if (!(e instanceof IDBDatabase) || t in e || "string" != typeof t)
                        return;
                    if (b.get(t))
                        return b.get(t);
                    const n = t.replace(/FromIndex$/, "")
                        , r = t !== n
                        , i = _.includes(n);
                    if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !i && !w.includes(n))
                        return;
                    const s = async function (e, ...t) {
                        const s = this.transaction(e, i ? "readwrite" : "readonly");
                        let o = s.store;
                        return r && (o = o.index(t.shift())),
                            (await Promise.all([o[n](...t), i && s.done]))[0]
                    };
                    return b.set(t, s),
                        s
                }

                p = (e => ({
                    ...e,
                    get: (t, n, r) => I(t, n) || e.get(t, n, r),
                    has: (t, n) => !!I(t, n) || e.has(t, n)
                }))(p);

                class T {
                    constructor(e) {
                        this.container = e
                    }

                    getPlatformInfoString() {
                        return this.container.getProviders().map((e => {
                                if (function (e) {
                                    const t = e.getComponent();
                                    return "VERSION" === (null == t ? void 0 : t.type)
                                }(e)) {
                                    const t = e.getImmediate();
                                    return `${t.library}/${t.version}`
                                }
                                return null
                            }
                        )).filter((e => e)).join(" ")
                    }
                }

                const E = "@firebase/app"
                    , k = "0.9.13"
                    , S = new i.Yd("@firebase/app")
                    , R = "[DEFAULT]"
                    , A = {
                    [E]: "fire-core",
                    "@firebase/app-compat": "fire-core-compat",
                    "@firebase/analytics": "fire-analytics",
                    "@firebase/analytics-compat": "fire-analytics-compat",
                    "@firebase/app-check": "fire-app-check",
                    "@firebase/app-check-compat": "fire-app-check-compat",
                    "@firebase/auth": "fire-auth",
                    "@firebase/auth-compat": "fire-auth-compat",
                    "@firebase/database": "fire-rtdb",
                    "@firebase/database-compat": "fire-rtdb-compat",
                    "@firebase/functions": "fire-fn",
                    "@firebase/functions-compat": "fire-fn-compat",
                    "@firebase/installations": "fire-iid",
                    "@firebase/installations-compat": "fire-iid-compat",
                    "@firebase/messaging": "fire-fcm",
                    "@firebase/messaging-compat": "fire-fcm-compat",
                    "@firebase/performance": "fire-perf",
                    "@firebase/performance-compat": "fire-perf-compat",
                    "@firebase/remote-config": "fire-rc",
                    "@firebase/remote-config-compat": "fire-rc-compat",
                    "@firebase/storage": "fire-gcs",
                    "@firebase/storage-compat": "fire-gcs-compat",
                    "@firebase/firestore": "fire-fst",
                    "@firebase/firestore-compat": "fire-fst-compat",
                    "fire-js": "fire-js",
                    firebase: "fire-js-all"
                }
                    , O = new Map
                    , C = new Map;

                function P(e, t) {
                    try {
                        e.container.addComponent(t)
                    } catch (n) {
                        S.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`, n)
                    }
                }

                function N(e) {
                    const t = e.name;
                    if (C.has(t))
                        return S.debug(`There were multiple attempts to register component ${t}.`),
                            !1;
                    C.set(t, e);
                    for (const t of O.values())
                        P(t, e);
                    return !0
                }

                function D(e, t) {
                    const n = e.container.getProvider("heartbeat").getImmediate({
                        optional: !0
                    });
                    return n && n.triggerHeartbeat(),
                        e.container.getProvider(t)
                }

                const L = {
                    "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
                    "bad-app-name": "Illegal App name: '{$appName}",
                    "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
                    "app-deleted": "Firebase App named '{$appName}' already deleted",
                    "no-options": "Need to provide options, when not being deployed to hosting via source.",
                    "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
                    "invalid-log-argument": "First argument to `onLog` must be null or a function.",
                    "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
                    "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
                    "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
                    "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
                }
                    , M = new s.LL("app", "Firebase", L);

                class U {
                    constructor(e, t, n) {
                        this._isDeleted = !1,
                            this._options = Object.assign({}, e),
                            this._config = Object.assign({}, t),
                            this._name = t.name,
                            this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled,
                            this._container = n,
                            this.container.addComponent(new r.wA("app", (() => this), "PUBLIC"))
                    }

                    get automaticDataCollectionEnabled() {
                        return this.checkDestroyed(),
                            this._automaticDataCollectionEnabled
                    }

                    set automaticDataCollectionEnabled(e) {
                        this.checkDestroyed(),
                            this._automaticDataCollectionEnabled = e
                    }

                    get name() {
                        return this.checkDestroyed(),
                            this._name
                    }

                    get options() {
                        return this.checkDestroyed(),
                            this._options
                    }

                    get config() {
                        return this.checkDestroyed(),
                            this._config
                    }

                    get container() {
                        return this._container
                    }

                    get isDeleted() {
                        return this._isDeleted
                    }

                    set isDeleted(e) {
                        this._isDeleted = e
                    }

                    checkDestroyed() {
                        if (this.isDeleted)
                            throw M.create("app-deleted", {
                                appName: this._name
                            })
                    }
                }

                const x = "9.23.0";

                function F(e, t = {}) {
                    let n = e;
                    if ("object" != typeof t) {
                        t = {
                            name: t
                        }
                    }
                    const i = Object.assign({
                        name: R,
                        automaticDataCollectionEnabled: !1
                    }, t)
                        , o = i.name;
                    if ("string" != typeof o || !o)
                        throw M.create("bad-app-name", {
                            appName: String(o)
                        });
                    if (n || (n = (0,
                        s.aH)()),
                        !n)
                        throw M.create("no-options");
                    const a = O.get(o);
                    if (a) {
                        if ((0,
                            s.vZ)(n, a.options) && (0,
                            s.vZ)(i, a.config))
                            return a;
                        throw M.create("duplicate-app", {
                            appName: o
                        })
                    }
                    const c = new r.H0(o);
                    for (const e of C.values())
                        c.addComponent(e);
                    const u = new U(n, i, c);
                    return O.set(o, u),
                        u
                }

                function V(e = R) {
                    const t = O.get(e);
                    if (!t && e === R && (0,
                        s.aH)())
                        return F();
                    if (!t)
                        throw M.create("no-app", {
                            appName: e
                        });
                    return t
                }

                function j(e, t, n) {
                    var i;
                    let s = null !== (i = A[e]) && void 0 !== i ? i : e;
                    n && (s += `-${n}`);
                    const o = s.match(/\s|\//)
                        , a = t.match(/\s|\//);
                    if (o || a) {
                        const e = [`Unable to register library "${s}" with version "${t}":`];
                        return o && e.push(`library name "${s}" contains illegal characters (whitespace or "/")`),
                        o && a && e.push("and"),
                        a && e.push(`version name "${t}" contains illegal characters (whitespace or "/")`),
                            void S.warn(e.join(" "))
                    }
                    N(new r.wA(`${s}-version`, (() => ({
                        library: s,
                        version: t
                    })), "VERSION"))
                }

                const z = "firebase-heartbeat-database"
                    , $ = 1
                    , B = "firebase-heartbeat-store";
                let H = null;

                function W() {
                    return H || (H = function (e, t, {blocked: n, upgrade: r, blocking: i, terminated: s} = {}) {
                        const o = indexedDB.open(e, t)
                            , a = v(o);
                        return r && o.addEventListener("upgradeneeded", (e => {
                                r(v(o.result), e.oldVersion, e.newVersion, v(o.transaction), e)
                            }
                        )),
                        n && o.addEventListener("blocked", (e => n(e.oldVersion, e.newVersion, e))),
                            a.then((e => {
                                    s && e.addEventListener("close", (() => s())),
                                    i && e.addEventListener("versionchange", (e => i(e.oldVersion, e.newVersion, e)))
                                }
                            )).catch((() => {
                                }
                            )),
                            a
                    }(z, $, {
                        upgrade: (e, t) => {
                            if (0 === t)
                                e.createObjectStore(B)
                        }
                    }).catch((e => {
                            throw M.create("idb-open", {
                                originalErrorMessage: e.message
                            })
                        }
                    ))),
                        H
                }

                async function q(e, t) {
                    try {
                        const n = (await W()).transaction(B, "readwrite")
                            , r = n.objectStore(B);
                        await r.put(t, K(e)),
                            await n.done
                    } catch (e) {
                        if (e instanceof s.ZR)
                            S.warn(e.message);
                        else {
                            const t = M.create("idb-set", {
                                originalErrorMessage: null == e ? void 0 : e.message
                            });
                            S.warn(t.message)
                        }
                    }
                }

                function K(e) {
                    return `${e.name}!${e.options.appId}`
                }

                class J {
                    constructor(e) {
                        this.container = e,
                            this._heartbeatsCache = null;
                        const t = this.container.getProvider("app").getImmediate();
                        this._storage = new X(t),
                            this._heartbeatsCachePromise = this._storage.read().then((e => (this._heartbeatsCache = e,
                                e)))
                    }

                    async triggerHeartbeat() {
                        const e = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString()
                            , t = G();
                        if (null === this._heartbeatsCache && (this._heartbeatsCache = await this._heartbeatsCachePromise),
                        this._heartbeatsCache.lastSentHeartbeatDate !== t && !this._heartbeatsCache.heartbeats.some((e => e.date === t)))
                            return this._heartbeatsCache.heartbeats.push({
                                date: t,
                                agent: e
                            }),
                                this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((e => {
                                        const t = new Date(e.date).valueOf();
                                        return Date.now() - t <= 2592e6
                                    }
                                )),
                                this._storage.overwrite(this._heartbeatsCache)
                    }

                    async getHeartbeatsHeader() {
                        if (null === this._heartbeatsCache && await this._heartbeatsCachePromise,
                        null === this._heartbeatsCache || 0 === this._heartbeatsCache.heartbeats.length)
                            return "";
                        const e = G()
                            , {heartbeatsToSend: t, unsentEntries: n} = function (e, t = 1024) {
                            const n = [];
                            let r = e.slice();
                            for (const i of e) {
                                const e = n.find((e => e.agent === i.agent));
                                if (e) {
                                    if (e.dates.push(i.date),
                                    Y(n) > t) {
                                        e.dates.pop();
                                        break
                                    }
                                } else if (n.push({
                                    agent: i.agent,
                                    dates: [i.date]
                                }),
                                Y(n) > t) {
                                    n.pop();
                                    break
                                }
                                r = r.slice(1)
                            }
                            return {
                                heartbeatsToSend: n,
                                unsentEntries: r
                            }
                        }(this._heartbeatsCache.heartbeats)
                            , r = (0,
                            s.L)(JSON.stringify({
                            version: 2,
                            heartbeats: t
                        }));
                        return this._heartbeatsCache.lastSentHeartbeatDate = e,
                            n.length > 0 ? (this._heartbeatsCache.heartbeats = n,
                                await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [],
                                this._storage.overwrite(this._heartbeatsCache)),
                            r
                    }
                }

                function G() {
                    return (new Date).toISOString().substring(0, 10)
                }

                class X {
                    constructor(e) {
                        this.app = e,
                            this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck()
                    }

                    async runIndexedDBEnvironmentCheck() {
                        return !!(0,
                            s.hl)() && (0,
                            s.eu)().then((() => !0)).catch((() => !1))
                    }

                    async read() {
                        if (await this._canUseIndexedDBPromise) {
                            return await async function (e) {
                                try {
                                    const t = await W();
                                    return await t.transaction(B).objectStore(B).get(K(e))
                                } catch (e) {
                                    if (e instanceof s.ZR)
                                        S.warn(e.message);
                                    else {
                                        const t = M.create("idb-get", {
                                            originalErrorMessage: null == e ? void 0 : e.message
                                        });
                                        S.warn(t.message)
                                    }
                                }
                            }(this.app) || {
                                heartbeats: []
                            }
                        }
                        return {
                            heartbeats: []
                        }
                    }

                    async overwrite(e) {
                        var t;
                        if (await this._canUseIndexedDBPromise) {
                            const n = await this.read();
                            return q(this.app, {
                                lastSentHeartbeatDate: null !== (t = e.lastSentHeartbeatDate) && void 0 !== t ? t : n.lastSentHeartbeatDate,
                                heartbeats: e.heartbeats
                            })
                        }
                    }

                    async add(e) {
                        var t;
                        if (await this._canUseIndexedDBPromise) {
                            const n = await this.read();
                            return q(this.app, {
                                lastSentHeartbeatDate: null !== (t = e.lastSentHeartbeatDate) && void 0 !== t ? t : n.lastSentHeartbeatDate,
                                heartbeats: [...n.heartbeats, ...e.heartbeats]
                            })
                        }
                    }
                }

                function Y(e) {
                    return (0,
                        s.L)(JSON.stringify({
                        version: 2,
                        heartbeats: e
                    })).length
                }

                var Q;
                Q = "",
                    N(new r.wA("platform-logger", (e => new T(e)), "PRIVATE")),
                    N(new r.wA("heartbeat", (e => new J(e)), "PRIVATE")),
                    j(E, k, Q),
                    j(E, k, "esm2017"),
                    j("fire-js", "")
            },
            1869: function (e, t, n) {
                n.d(t, {
                    H0: function () {
                        return a
                    },
                    wA: function () {
                        return i
                    }
                });
                var r = n(6258);

                class i {
                    constructor(e, t, n) {
                        this.name = e,
                            this.instanceFactory = t,
                            this.type = n,
                            this.multipleInstances = !1,
                            this.serviceProps = {},
                            this.instantiationMode = "LAZY",
                            this.onInstanceCreated = null
                    }

                    setInstantiationMode(e) {
                        return this.instantiationMode = e,
                            this
                    }

                    setMultipleInstances(e) {
                        return this.multipleInstances = e,
                            this
                    }

                    setServiceProps(e) {
                        return this.serviceProps = e,
                            this
                    }

                    setInstanceCreatedCallback(e) {
                        return this.onInstanceCreated = e,
                            this
                    }
                }

                const s = "[DEFAULT]";

                class o {
                    constructor(e, t) {
                        this.name = e,
                            this.container = t,
                            this.component = null,
                            this.instances = new Map,
                            this.instancesDeferred = new Map,
                            this.instancesOptions = new Map,
                            this.onInitCallbacks = new Map
                    }

                    get(e) {
                        const t = this.normalizeInstanceIdentifier(e);
                        if (!this.instancesDeferred.has(t)) {
                            const e = new r.BH;
                            if (this.instancesDeferred.set(t, e),
                            this.isInitialized(t) || this.shouldAutoInitialize())
                                try {
                                    const n = this.getOrInitializeService({
                                        instanceIdentifier: t
                                    });
                                    n && e.resolve(n)
                                } catch (e) {
                                }
                        }
                        return this.instancesDeferred.get(t).promise
                    }

                    getImmediate(e) {
                        var t;
                        const n = this.normalizeInstanceIdentifier(null == e ? void 0 : e.identifier)
                            , r = null !== (t = null == e ? void 0 : e.optional) && void 0 !== t && t;
                        if (!this.isInitialized(n) && !this.shouldAutoInitialize()) {
                            if (r)
                                return null;
                            throw Error(`Service ${this.name} is not available`)
                        }
                        try {
                            return this.getOrInitializeService({
                                instanceIdentifier: n
                            })
                        } catch (e) {
                            if (r)
                                return null;
                            throw e
                        }
                    }

                    getComponent() {
                        return this.component
                    }

                    setComponent(e) {
                        if (e.name !== this.name)
                            throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
                        if (this.component)
                            throw Error(`Component for ${this.name} has already been provided`);
                        if (this.component = e,
                            this.shouldAutoInitialize()) {
                            if (function (e) {
                                return "EAGER" === e.instantiationMode
                            }(e))
                                try {
                                    this.getOrInitializeService({
                                        instanceIdentifier: s
                                    })
                                } catch (e) {
                                }
                            for (const [e, t] of this.instancesDeferred.entries()) {
                                const n = this.normalizeInstanceIdentifier(e);
                                try {
                                    const e = this.getOrInitializeService({
                                        instanceIdentifier: n
                                    });
                                    t.resolve(e)
                                } catch (e) {
                                }
                            }
                        }
                    }

                    clearInstance(e = s) {
                        this.instancesDeferred.delete(e),
                            this.instancesOptions.delete(e),
                            this.instances.delete(e)
                    }

                    async delete() {
                        const e = Array.from(this.instances.values());
                        await Promise.all([...e.filter((e => "INTERNAL" in e)).map((e => e.INTERNAL.delete())), ...e.filter((e => "_delete" in e)).map((e => e._delete()))])
                    }

                    isComponentSet() {
                        return null != this.component
                    }

                    isInitialized(e = s) {
                        return this.instances.has(e)
                    }

                    getOptions(e = s) {
                        return this.instancesOptions.get(e) || {}
                    }

                    initialize(e = {}) {
                        const {options: t = {}} = e
                            , n = this.normalizeInstanceIdentifier(e.instanceIdentifier);
                        if (this.isInitialized(n))
                            throw Error(`${this.name}(${n}) has already been initialized`);
                        if (!this.isComponentSet())
                            throw Error(`Component ${this.name} has not been registered yet`);
                        const r = this.getOrInitializeService({
                            instanceIdentifier: n,
                            options: t
                        });
                        for (const [e, t] of this.instancesDeferred.entries()) {
                            n === this.normalizeInstanceIdentifier(e) && t.resolve(r)
                        }
                        return r
                    }

                    onInit(e, t) {
                        var n;
                        const r = this.normalizeInstanceIdentifier(t)
                            , i = null !== (n = this.onInitCallbacks.get(r)) && void 0 !== n ? n : new Set;
                        i.add(e),
                            this.onInitCallbacks.set(r, i);
                        const s = this.instances.get(r);
                        return s && e(s, r),
                            () => {
                                i.delete(e)
                            }
                    }

                    invokeOnInitCallbacks(e, t) {
                        const n = this.onInitCallbacks.get(t);
                        if (n)
                            for (const r of n)
                                try {
                                    r(e, t)
                                } catch (e) {
                                }
                    }

                    getOrInitializeService({instanceIdentifier: e, options: t = {}}) {
                        let n = this.instances.get(e);
                        if (!n && this.component && (n = this.component.instanceFactory(this.container, {
                            instanceIdentifier: (r = e,
                                r === s ? void 0 : r),
                            options: t
                        }),
                            this.instances.set(e, n),
                            this.instancesOptions.set(e, t),
                            this.invokeOnInitCallbacks(n, e),
                            this.component.onInstanceCreated))
                            try {
                                this.component.onInstanceCreated(this.container, e, n)
                            } catch (e) {
                            }
                        var r;
                        return n || null
                    }

                    normalizeInstanceIdentifier(e = s) {
                        return this.component ? this.component.multipleInstances ? e : s : e
                    }

                    shouldAutoInitialize() {
                        return !!this.component && "EXPLICIT" !== this.component.instantiationMode
                    }
                }

                class a {
                    constructor(e) {
                        this.name = e,
                            this.providers = new Map
                    }

                    addComponent(e) {
                        const t = this.getProvider(e.name);
                        if (t.isComponentSet())
                            throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
                        t.setComponent(e)
                    }

                    addOrOverwriteComponent(e) {
                        this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name),
                            this.addComponent(e)
                    }

                    getProvider(e) {
                        if (this.providers.has(e))
                            return this.providers.get(e);
                        const t = new o(e, this);
                        return this.providers.set(e, t),
                            t
                    }

                    getProviders() {
                        return Array.from(this.providers.values())
                    }
                }
            },
            1711: function (e, t, n) {
                n.d(t, {
                    Yd: function () {
                        return u
                    },
                    in: function () {
                        return i
                    }
                });
                const r = [];
                var i;
                !function (e) {
                    e[e.DEBUG = 0] = "DEBUG",
                        e[e.VERBOSE = 1] = "VERBOSE",
                        e[e.INFO = 2] = "INFO",
                        e[e.WARN = 3] = "WARN",
                        e[e.ERROR = 4] = "ERROR",
                        e[e.SILENT = 5] = "SILENT"
                }(i || (i = {}));
                const s = {
                        debug: i.DEBUG,
                        verbose: i.VERBOSE,
                        info: i.INFO,
                        warn: i.WARN,
                        error: i.ERROR,
                        silent: i.SILENT
                    }
                    , o = i.INFO
                    , a = {
                        [i.DEBUG]: "log",
                        [i.VERBOSE]: "log",
                        [i.INFO]: "info",
                        [i.WARN]: "warn",
                        [i.ERROR]: "error"
                    }
                    , c = (e, t, ...n) => {
                        if (t < e.logLevel)
                            return;
                        const r = (new Date).toISOString()
                            , i = a[t];
                        if (!i)
                            throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);
                        console[i](`[${r}]  ${e.name}:`, ...n)
                    }
                ;

                class u {
                    constructor(e) {
                        this.name = e,
                            this._logLevel = o,
                            this._logHandler = c,
                            this._userLogHandler = null,
                            r.push(this)
                    }

                    get logLevel() {
                        return this._logLevel
                    }

                    set logLevel(e) {
                        if (!(e in i))
                            throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
                        this._logLevel = e
                    }

                    setLogLevel(e) {
                        this._logLevel = "string" == typeof e ? s[e] : e
                    }

                    get logHandler() {
                        return this._logHandler
                    }

                    set logHandler(e) {
                        if ("function" != typeof e)
                            throw new TypeError("Value assigned to `logHandler` must be a function");
                        this._logHandler = e
                    }

                    get userLogHandler() {
                        return this._userLogHandler
                    }

                    set userLogHandler(e) {
                        this._userLogHandler = e
                    }

                    debug(...e) {
                        this._userLogHandler && this._userLogHandler(this, i.DEBUG, ...e),
                            this._logHandler(this, i.DEBUG, ...e)
                    }

                    log(...e) {
                        this._userLogHandler && this._userLogHandler(this, i.VERBOSE, ...e),
                            this._logHandler(this, i.VERBOSE, ...e)
                    }

                    info(...e) {
                        this._userLogHandler && this._userLogHandler(this, i.INFO, ...e),
                            this._logHandler(this, i.INFO, ...e)
                    }

                    warn(...e) {
                        this._userLogHandler && this._userLogHandler(this, i.WARN, ...e),
                            this._logHandler(this, i.WARN, ...e)
                    }

                    error(...e) {
                        this._userLogHandler && this._userLogHandler(this, i.ERROR, ...e),
                            this._logHandler(this, i.ERROR, ...e)
                    }
                }
            },
            4316: function (e, t, n) {
                n.d(t, {
                    ZF: function () {
                        return r.ZF
                    }
                });
                var r = n(9904);
                (0,
                    r.KN)("firebase", "9.23.0", "app")
            },
            4742: function (e, t, n) {
                n.d(t, {
                    v0: function () {
                        return hn
                    },
                    Aj: function () {
                        return qe
                    },
                    _p: function () {
                        return We
                    }
                });
                var r = n(6258)
                    , i = n(9904);

                function s(e, t) {
                    var n = {};
                    for (var r in e)
                        Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
                    if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                        var i = 0;
                        for (r = Object.getOwnPropertySymbols(e); i < r.length; i++)
                            t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]])
                    }
                    return n
                }

                Object.create;
                Object.create;
                "function" == typeof SuppressedError && SuppressedError;
                var o = n(1711)
                    , a = n(1869);

                function c() {
                    return {
                        "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
                    }
                }

                const u = c
                    , l = new r.LL("auth", "Firebase", {
                    "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
                })
                    , h = new o.Yd("@firebase/auth");

                function d(e, ...t) {
                    h.logLevel <= o.in.ERROR && h.error(`Auth (${i.Jn}): ${e}`, ...t)
                }

                function f(e, ...t) {
                    throw g(e, ...t)
                }

                function p(e, ...t) {
                    return g(e, ...t)
                }

                function m(e, t, n) {
                    const i = Object.assign(Object.assign({}, u()), {
                        [t]: n
                    });
                    return new r.LL("auth", "Firebase", i).create(t, {
                        appName: e.name
                    })
                }

                function g(e, ...t) {
                    if ("string" != typeof e) {
                        const n = t[0]
                            , r = [...t.slice(1)];
                        return r[0] && (r[0].appName = e.name),
                            e._errorFactory.create(n, ...r)
                    }
                    return l.create(e, ...t)
                }

                function v(e, t, ...n) {
                    if (!e)
                        throw g(t, ...n)
                }

                function y(e) {
                    const t = "INTERNAL ASSERTION FAILED: " + e;
                    throw d(t),
                        new Error(t)
                }

                function w(e, t) {
                    e || y(t)
                }

                function _() {
                    var e;
                    return "undefined" != typeof self && (null === (e = self.location) || void 0 === e ? void 0 : e.href) || ""
                }

                function b() {
                    return "http:" === I() || "https:" === I()
                }

                function I() {
                    var e;
                    return "undefined" != typeof self && (null === (e = self.location) || void 0 === e ? void 0 : e.protocol) || null
                }

                class T {
                    constructor(e, t) {
                        this.shortDelay = e,
                            this.longDelay = t,
                            w(t > e, "Short delay should be less than long delay!"),
                            this.isMobile = (0,
                                r.uI)() || (0,
                                r.b$)()
                    }

                    get() {
                        return "undefined" != typeof navigator && navigator && "onLine" in navigator && "boolean" == typeof navigator.onLine && (b() || (0,
                            r.ru)() || "connection" in navigator) && !navigator.onLine ? Math.min(5e3, this.shortDelay) : this.isMobile ? this.longDelay : this.shortDelay
                    }
                }

                function E(e, t) {
                    w(e.emulator, "Emulator should always be set here");
                    const {url: n} = e.emulator;
                    return t ? `${n}${t.startsWith("/") ? t.slice(1) : t}` : n
                }

                class k {
                    static initialize(e, t, n) {
                        this.fetchImpl = e,
                        t && (this.headersImpl = t),
                        n && (this.responseImpl = n)
                    }

                    static fetch() {
                        return this.fetchImpl ? this.fetchImpl : "undefined" != typeof self && "fetch" in self ? self.fetch : void y("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
                    }

                    static headers() {
                        return this.headersImpl ? this.headersImpl : "undefined" != typeof self && "Headers" in self ? self.Headers : void y("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
                    }

                    static response() {
                        return this.responseImpl ? this.responseImpl : "undefined" != typeof self && "Response" in self ? self.Response : void y("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
                    }
                }

                const S = {
                    CREDENTIAL_MISMATCH: "custom-token-mismatch",
                    MISSING_CUSTOM_TOKEN: "internal-error",
                    INVALID_IDENTIFIER: "invalid-email",
                    MISSING_CONTINUE_URI: "internal-error",
                    INVALID_PASSWORD: "wrong-password",
                    MISSING_PASSWORD: "missing-password",
                    EMAIL_EXISTS: "email-already-in-use",
                    PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
                    INVALID_IDP_RESPONSE: "invalid-credential",
                    INVALID_PENDING_TOKEN: "invalid-credential",
                    FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
                    MISSING_REQ_TYPE: "internal-error",
                    EMAIL_NOT_FOUND: "user-not-found",
                    RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
                    EXPIRED_OOB_CODE: "expired-action-code",
                    INVALID_OOB_CODE: "invalid-action-code",
                    MISSING_OOB_CODE: "internal-error",
                    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
                    INVALID_ID_TOKEN: "invalid-user-token",
                    TOKEN_EXPIRED: "user-token-expired",
                    USER_NOT_FOUND: "user-token-expired",
                    TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
                    INVALID_CODE: "invalid-verification-code",
                    INVALID_SESSION_INFO: "invalid-verification-id",
                    INVALID_TEMPORARY_PROOF: "invalid-credential",
                    MISSING_SESSION_INFO: "missing-verification-id",
                    SESSION_EXPIRED: "code-expired",
                    MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
                    UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
                    INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
                    ADMIN_ONLY_OPERATION: "admin-restricted-operation",
                    INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
                    MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
                    MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
                    MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
                    SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
                    SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
                    BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error",
                    RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled",
                    MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token",
                    INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token",
                    INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action",
                    MISSING_CLIENT_TYPE: "missing-client-type",
                    MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version",
                    INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version",
                    INVALID_REQ_TYPE: "invalid-req-type"
                }
                    , R = new T(3e4, 6e4);

                function A(e, t) {
                    return e.tenantId && !t.tenantId ? Object.assign(Object.assign({}, t), {
                        tenantId: e.tenantId
                    }) : t
                }

                async function O(e, t, n, i, s = {}) {
                    return C(e, s, (async () => {
                            let s = {}
                                , o = {};
                            i && ("GET" === t ? o = i : s = {
                                body: JSON.stringify(i)
                            });
                            const a = (0,
                                r.xO)(Object.assign({
                                key: e.config.apiKey
                            }, o)).slice(1)
                                , c = await e._getAdditionalHeaders();
                            return c["Content-Type"] = "application/json",
                            e.languageCode && (c["X-Firebase-Locale"] = e.languageCode),
                                k.fetch()(N(e, e.config.apiHost, n, a), Object.assign({
                                    method: t,
                                    headers: c,
                                    referrerPolicy: "no-referrer"
                                }, s))
                        }
                    ))
                }

                async function C(e, t, n) {
                    e._canInitEmulator = !1;
                    const i = Object.assign(Object.assign({}, S), t);
                    try {
                        const t = new D(e)
                            , r = await Promise.race([n(), t.promise]);
                        t.clearNetworkTimeout();
                        const s = await r.json();
                        if ("needConfirmation" in s)
                            throw L(e, "account-exists-with-different-credential", s);
                        if (r.ok && !("errorMessage" in s))
                            return s;
                        {
                            const t = r.ok ? s.errorMessage : s.error.message
                                , [n, o] = t.split(" : ");
                            if ("FEDERATED_USER_ID_ALREADY_LINKED" === n)
                                throw L(e, "credential-already-in-use", s);
                            if ("EMAIL_EXISTS" === n)
                                throw L(e, "email-already-in-use", s);
                            if ("USER_DISABLED" === n)
                                throw L(e, "user-disabled", s);
                            const a = i[n] || n.toLowerCase().replace(/[_\s]+/g, "-");
                            if (o)
                                throw m(e, a, o);
                            f(e, a)
                        }
                    } catch (t) {
                        if (t instanceof r.ZR)
                            throw t;
                        f(e, "network-request-failed", {
                            message: String(t)
                        })
                    }
                }

                async function P(e, t, n, r, i = {}) {
                    const s = await O(e, t, n, r, i);
                    return "mfaPendingCredential" in s && f(e, "multi-factor-auth-required", {
                        _serverResponse: s
                    }),
                        s
                }

                function N(e, t, n, r) {
                    const i = `${t}${n}?${r}`;
                    return e.config.emulator ? E(e.config, i) : `${e.config.apiScheme}://${i}`
                }

                class D {
                    constructor(e) {
                        this.auth = e,
                            this.timer = null,
                            this.promise = new Promise(((e, t) => {
                                    this.timer = setTimeout((() => t(p(this.auth, "network-request-failed"))), R.get())
                                }
                            ))
                    }

                    clearNetworkTimeout() {
                        clearTimeout(this.timer)
                    }
                }

                function L(e, t, n) {
                    const r = {
                        appName: e.name
                    };
                    n.email && (r.email = n.email),
                    n.phoneNumber && (r.phoneNumber = n.phoneNumber);
                    const i = p(e, t, r);
                    return i.customData._tokenResponse = n,
                        i
                }

                function M(e) {
                    if (e)
                        try {
                            const t = new Date(Number(e));
                            if (!isNaN(t.getTime()))
                                return t.toUTCString()
                        } catch (e) {
                        }
                }

                function U(e) {
                    return 1e3 * Number(e)
                }

                function x(e) {
                    const [t, n, i] = e.split(".");
                    if (void 0 === t || void 0 === n || void 0 === i)
                        return d("JWT malformed, contained fewer than 3 sections"),
                            null;
                    try {
                        const e = (0,
                            r.tV)(n);
                        return e ? JSON.parse(e) : (d("Failed to decode base64 JWT payload"),
                            null)
                    } catch (e) {
                        return d("Caught error parsing JWT payload as JSON", null == e ? void 0 : e.toString()),
                            null
                    }
                }

                async function F(e, t, n = !1) {
                    if (n)
                        return t;
                    try {
                        return await t
                    } catch (t) {
                        throw t instanceof r.ZR && function ({code: e}) {
                            return "auth/user-disabled" === e || "auth/user-token-expired" === e
                        }(t) && e.auth.currentUser === e && await e.auth.signOut(),
                            t
                    }
                }

                class V {
                    constructor(e) {
                        this.user = e,
                            this.isRunning = !1,
                            this.timerId = null,
                            this.errorBackoff = 3e4
                    }

                    _start() {
                        this.isRunning || (this.isRunning = !0,
                            this.schedule())
                    }

                    _stop() {
                        this.isRunning && (this.isRunning = !1,
                        null !== this.timerId && clearTimeout(this.timerId))
                    }

                    getInterval(e) {
                        var t;
                        if (e) {
                            const e = this.errorBackoff;
                            return this.errorBackoff = Math.min(2 * this.errorBackoff, 96e4),
                                e
                        }
                        {
                            this.errorBackoff = 3e4;
                            const e = (null !== (t = this.user.stsTokenManager.expirationTime) && void 0 !== t ? t : 0) - Date.now() - 3e5;
                            return Math.max(0, e)
                        }
                    }

                    schedule(e = !1) {
                        if (!this.isRunning)
                            return;
                        const t = this.getInterval(e);
                        this.timerId = setTimeout((async () => {
                                await this.iteration()
                            }
                        ), t)
                    }

                    async iteration() {
                        try {
                            await this.user.getIdToken(!0)
                        } catch (e) {
                            return void ("auth/network-request-failed" === (null == e ? void 0 : e.code) && this.schedule(!0))
                        }
                        this.schedule()
                    }
                }

                class j {
                    constructor(e, t) {
                        this.createdAt = e,
                            this.lastLoginAt = t,
                            this._initializeTime()
                    }

                    _initializeTime() {
                        this.lastSignInTime = M(this.lastLoginAt),
                            this.creationTime = M(this.createdAt)
                    }

                    _copy(e) {
                        this.createdAt = e.createdAt,
                            this.lastLoginAt = e.lastLoginAt,
                            this._initializeTime()
                    }

                    toJSON() {
                        return {
                            createdAt: this.createdAt,
                            lastLoginAt: this.lastLoginAt
                        }
                    }
                }

                async function z(e) {
                    var t;
                    const n = e.auth
                        , r = await e.getIdToken()
                        , i = await F(e, async function (e, t) {
                        return O(e, "POST", "/v1/accounts:lookup", t)
                    }(n, {
                        idToken: r
                    }));
                    v(null == i ? void 0 : i.users.length, n, "internal-error");
                    const o = i.users[0];
                    e._notifyReloadListener(o);
                    const a = (null === (t = o.providerUserInfo) || void 0 === t ? void 0 : t.length) ? o.providerUserInfo.map((e => {
                            var {providerId: t} = e
                                , n = s(e, ["providerId"]);
                            return {
                                providerId: t,
                                uid: n.rawId || "",
                                displayName: n.displayName || null,
                                email: n.email || null,
                                phoneNumber: n.phoneNumber || null,
                                photoURL: n.photoUrl || null
                            }
                        }
                    )) : [];
                    const c = (u = e.providerData,
                        l = a,
                        [...u.filter((e => !l.some((t => t.providerId === e.providerId)))), ...l]);
                    var u, l;
                    const h = e.isAnonymous
                        , d = !(e.email && o.passwordHash || (null == c ? void 0 : c.length))
                        , f = !!h && d
                        , p = {
                        uid: o.localId,
                        displayName: o.displayName || null,
                        photoURL: o.photoUrl || null,
                        email: o.email || null,
                        emailVerified: o.emailVerified || !1,
                        phoneNumber: o.phoneNumber || null,
                        tenantId: o.tenantId || null,
                        providerData: c,
                        metadata: new j(o.createdAt, o.lastLoginAt),
                        isAnonymous: f
                    };
                    Object.assign(e, p)
                }

                class $ {
                    constructor() {
                        this.refreshToken = null,
                            this.accessToken = null,
                            this.expirationTime = null
                    }

                    get isExpired() {
                        return !this.expirationTime || Date.now() > this.expirationTime - 3e4
                    }

                    updateFromServerResponse(e) {
                        v(e.idToken, "internal-error"),
                            v(void 0 !== e.idToken, "internal-error"),
                            v(void 0 !== e.refreshToken, "internal-error");
                        const t = "expiresIn" in e && void 0 !== e.expiresIn ? Number(e.expiresIn) : function (e) {
                            const t = x(e);
                            return v(t, "internal-error"),
                                v(void 0 !== t.exp, "internal-error"),
                                v(void 0 !== t.iat, "internal-error"),
                            Number(t.exp) - Number(t.iat)
                        }(e.idToken);
                        this.updateTokensAndExpiration(e.idToken, e.refreshToken, t)
                    }

                    async getToken(e, t = !1) {
                        return v(!this.accessToken || this.refreshToken, e, "user-token-expired"),
                            t || !this.accessToken || this.isExpired ? this.refreshToken ? (await this.refresh(e, this.refreshToken),
                                this.accessToken) : null : this.accessToken
                    }

                    clearRefreshToken() {
                        this.refreshToken = null
                    }

                    async refresh(e, t) {
                        const {accessToken: n, refreshToken: i, expiresIn: s} = await async function (e, t) {
                            const n = await C(e, {}, (async () => {
                                    const n = (0,
                                        r.xO)({
                                        grant_type: "refresh_token",
                                        refresh_token: t
                                    }).slice(1)
                                        , {tokenApiHost: i, apiKey: s} = e.config
                                        , o = N(e, i, "/v1/token", `key=${s}`)
                                        , a = await e._getAdditionalHeaders();
                                    return a["Content-Type"] = "application/x-www-form-urlencoded",
                                        k.fetch()(o, {
                                            method: "POST",
                                            headers: a,
                                            body: n
                                        })
                                }
                            ));
                            return {
                                accessToken: n.access_token,
                                expiresIn: n.expires_in,
                                refreshToken: n.refresh_token
                            }
                        }(e, t);
                        this.updateTokensAndExpiration(n, i, Number(s))
                    }

                    updateTokensAndExpiration(e, t, n) {
                        this.refreshToken = t || null,
                            this.accessToken = e || null,
                            this.expirationTime = Date.now() + 1e3 * n
                    }

                    static fromJSON(e, t) {
                        const {refreshToken: n, accessToken: r, expirationTime: i} = t
                            , s = new $;
                        return n && (v("string" == typeof n, "internal-error", {
                            appName: e
                        }),
                            s.refreshToken = n),
                        r && (v("string" == typeof r, "internal-error", {
                            appName: e
                        }),
                            s.accessToken = r),
                        i && (v("number" == typeof i, "internal-error", {
                            appName: e
                        }),
                            s.expirationTime = i),
                            s
                    }

                    toJSON() {
                        return {
                            refreshToken: this.refreshToken,
                            accessToken: this.accessToken,
                            expirationTime: this.expirationTime
                        }
                    }

                    _assign(e) {
                        this.accessToken = e.accessToken,
                            this.refreshToken = e.refreshToken,
                            this.expirationTime = e.expirationTime
                    }

                    _clone() {
                        return Object.assign(new $, this.toJSON())
                    }

                    _performRefresh() {
                        return y("not implemented")
                    }
                }

                function B(e, t) {
                    v("string" == typeof e || void 0 === e, "internal-error", {
                        appName: t
                    })
                }

                class H {
                    constructor(e) {
                        var {uid: t, auth: n, stsTokenManager: r} = e
                            , i = s(e, ["uid", "auth", "stsTokenManager"]);
                        this.providerId = "firebase",
                            this.proactiveRefresh = new V(this),
                            this.reloadUserInfo = null,
                            this.reloadListener = null,
                            this.uid = t,
                            this.auth = n,
                            this.stsTokenManager = r,
                            this.accessToken = r.accessToken,
                            this.displayName = i.displayName || null,
                            this.email = i.email || null,
                            this.emailVerified = i.emailVerified || !1,
                            this.phoneNumber = i.phoneNumber || null,
                            this.photoURL = i.photoURL || null,
                            this.isAnonymous = i.isAnonymous || !1,
                            this.tenantId = i.tenantId || null,
                            this.providerData = i.providerData ? [...i.providerData] : [],
                            this.metadata = new j(i.createdAt || void 0, i.lastLoginAt || void 0)
                    }

                    async getIdToken(e) {
                        const t = await F(this, this.stsTokenManager.getToken(this.auth, e));
                        return v(t, this.auth, "internal-error"),
                        this.accessToken !== t && (this.accessToken = t,
                            await this.auth._persistUserIfCurrent(this),
                            this.auth._notifyListenersIfCurrent(this)),
                            t
                    }

                    getIdTokenResult(e) {
                        return async function (e, t = !1) {
                            const n = (0,
                                r.m9)(e)
                                , i = await n.getIdToken(t)
                                , s = x(i);
                            v(s && s.exp && s.auth_time && s.iat, n.auth, "internal-error");
                            const o = "object" == typeof s.firebase ? s.firebase : void 0
                                , a = null == o ? void 0 : o.sign_in_provider;
                            return {
                                claims: s,
                                token: i,
                                authTime: M(U(s.auth_time)),
                                issuedAtTime: M(U(s.iat)),
                                expirationTime: M(U(s.exp)),
                                signInProvider: a || null,
                                signInSecondFactor: (null == o ? void 0 : o.sign_in_second_factor) || null
                            }
                        }(this, e)
                    }

                    reload() {
                        return async function (e) {
                            const t = (0,
                                r.m9)(e);
                            await z(t),
                                await t.auth._persistUserIfCurrent(t),
                                t.auth._notifyListenersIfCurrent(t)
                        }(this)
                    }

                    _assign(e) {
                        this !== e && (v(this.uid === e.uid, this.auth, "internal-error"),
                            this.displayName = e.displayName,
                            this.photoURL = e.photoURL,
                            this.email = e.email,
                            this.emailVerified = e.emailVerified,
                            this.phoneNumber = e.phoneNumber,
                            this.isAnonymous = e.isAnonymous,
                            this.tenantId = e.tenantId,
                            this.providerData = e.providerData.map((e => Object.assign({}, e))),
                            this.metadata._copy(e.metadata),
                            this.stsTokenManager._assign(e.stsTokenManager))
                    }

                    _clone(e) {
                        const t = new H(Object.assign(Object.assign({}, this), {
                            auth: e,
                            stsTokenManager: this.stsTokenManager._clone()
                        }));
                        return t.metadata._copy(this.metadata),
                            t
                    }

                    _onReload(e) {
                        v(!this.reloadListener, this.auth, "internal-error"),
                            this.reloadListener = e,
                        this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo),
                            this.reloadUserInfo = null)
                    }

                    _notifyReloadListener(e) {
                        this.reloadListener ? this.reloadListener(e) : this.reloadUserInfo = e
                    }

                    _startProactiveRefresh() {
                        this.proactiveRefresh._start()
                    }

                    _stopProactiveRefresh() {
                        this.proactiveRefresh._stop()
                    }

                    async _updateTokensIfNecessary(e, t = !1) {
                        let n = !1;
                        e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e),
                            n = !0),
                        t && await z(this),
                            await this.auth._persistUserIfCurrent(this),
                        n && this.auth._notifyListenersIfCurrent(this)
                    }

                    async delete() {
                        const e = await this.getIdToken();
                        return await F(this, async function (e, t) {
                            return O(e, "POST", "/v1/accounts:delete", t)
                        }(this.auth, {
                            idToken: e
                        })),
                            this.stsTokenManager.clearRefreshToken(),
                            this.auth.signOut()
                    }

                    toJSON() {
                        return Object.assign(Object.assign({
                            uid: this.uid,
                            email: this.email || void 0,
                            emailVerified: this.emailVerified,
                            displayName: this.displayName || void 0,
                            isAnonymous: this.isAnonymous,
                            photoURL: this.photoURL || void 0,
                            phoneNumber: this.phoneNumber || void 0,
                            tenantId: this.tenantId || void 0,
                            providerData: this.providerData.map((e => Object.assign({}, e))),
                            stsTokenManager: this.stsTokenManager.toJSON(),
                            _redirectEventId: this._redirectEventId
                        }, this.metadata.toJSON()), {
                            apiKey: this.auth.config.apiKey,
                            appName: this.auth.name
                        })
                    }

                    get refreshToken() {
                        return this.stsTokenManager.refreshToken || ""
                    }

                    static _fromJSON(e, t) {
                        var n, r, i, s, o, a, c, u;
                        const l = null !== (n = t.displayName) && void 0 !== n ? n : void 0
                            , h = null !== (r = t.email) && void 0 !== r ? r : void 0
                            , d = null !== (i = t.phoneNumber) && void 0 !== i ? i : void 0
                            , f = null !== (s = t.photoURL) && void 0 !== s ? s : void 0
                            , p = null !== (o = t.tenantId) && void 0 !== o ? o : void 0
                            , m = null !== (a = t._redirectEventId) && void 0 !== a ? a : void 0
                            , g = null !== (c = t.createdAt) && void 0 !== c ? c : void 0
                            , y = null !== (u = t.lastLoginAt) && void 0 !== u ? u : void 0
                            , {uid: w, emailVerified: _, isAnonymous: b, providerData: I, stsTokenManager: T} = t;
                        v(w && T, e, "internal-error");
                        const E = $.fromJSON(this.name, T);
                        v("string" == typeof w, e, "internal-error"),
                            B(l, e.name),
                            B(h, e.name),
                            v("boolean" == typeof _, e, "internal-error"),
                            v("boolean" == typeof b, e, "internal-error"),
                            B(d, e.name),
                            B(f, e.name),
                            B(p, e.name),
                            B(m, e.name),
                            B(g, e.name),
                            B(y, e.name);
                        const k = new H({
                            uid: w,
                            auth: e,
                            email: h,
                            emailVerified: _,
                            displayName: l,
                            isAnonymous: b,
                            photoURL: f,
                            phoneNumber: d,
                            tenantId: p,
                            stsTokenManager: E,
                            createdAt: g,
                            lastLoginAt: y
                        });
                        return I && Array.isArray(I) && (k.providerData = I.map((e => Object.assign({}, e)))),
                        m && (k._redirectEventId = m),
                            k
                    }

                    static async _fromIdTokenResponse(e, t, n = !1) {
                        const r = new $;
                        r.updateFromServerResponse(t);
                        const i = new H({
                            uid: t.localId,
                            auth: e,
                            stsTokenManager: r,
                            isAnonymous: n
                        });
                        return await z(i),
                            i
                    }
                }

                const W = new Map;

                function q(e) {
                    w(e instanceof Function, "Expected a class definition");
                    let t = W.get(e);
                    return t ? (w(t instanceof e, "Instance stored in cache mismatched with class"),
                        t) : (t = new e,
                        W.set(e, t),
                        t)
                }

                class K {
                    constructor() {
                        this.type = "NONE",
                            this.storage = {}
                    }

                    async _isAvailable() {
                        return !0
                    }

                    async _set(e, t) {
                        this.storage[e] = t
                    }

                    async _get(e) {
                        const t = this.storage[e];
                        return void 0 === t ? null : t
                    }

                    async _remove(e) {
                        delete this.storage[e]
                    }

                    _addListener(e, t) {
                    }

                    _removeListener(e, t) {
                    }
                }

                K.type = "NONE";
                const J = K;

                function G(e, t, n) {
                    return `firebase:${e}:${t}:${n}`
                }

                class X {
                    constructor(e, t, n) {
                        this.persistence = e,
                            this.auth = t,
                            this.userKey = n;
                        const {config: r, name: i} = this.auth;
                        this.fullUserKey = G(this.userKey, r.apiKey, i),
                            this.fullPersistenceKey = G("persistence", r.apiKey, i),
                            this.boundEventHandler = t._onStorageEvent.bind(t),
                            this.persistence._addListener(this.fullUserKey, this.boundEventHandler)
                    }

                    setCurrentUser(e) {
                        return this.persistence._set(this.fullUserKey, e.toJSON())
                    }

                    async getCurrentUser() {
                        const e = await this.persistence._get(this.fullUserKey);
                        return e ? H._fromJSON(this.auth, e) : null
                    }

                    removeCurrentUser() {
                        return this.persistence._remove(this.fullUserKey)
                    }

                    savePersistenceForRedirect() {
                        return this.persistence._set(this.fullPersistenceKey, this.persistence.type)
                    }

                    async setPersistence(e) {
                        if (this.persistence === e)
                            return;
                        const t = await this.getCurrentUser();
                        return await this.removeCurrentUser(),
                            this.persistence = e,
                            t ? this.setCurrentUser(t) : void 0
                    }

                    delete() {
                        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler)
                    }

                    static async create(e, t, n = "authUser") {
                        if (!t.length)
                            return new X(q(J), e, n);
                        const r = (await Promise.all(t.map((async e => {
                                if (await e._isAvailable())
                                    return e
                            }
                        )))).filter((e => e));
                        let i = r[0] || q(J);
                        const s = G(n, e.config.apiKey, e.name);
                        let o = null;
                        for (const n of t)
                            try {
                                const t = await n._get(s);
                                if (t) {
                                    const r = H._fromJSON(e, t);
                                    n !== i && (o = r),
                                        i = n;
                                    break
                                }
                            } catch (e) {
                            }
                        const a = r.filter((e => e._shouldAllowMigration));
                        return i._shouldAllowMigration && a.length ? (i = a[0],
                        o && await i._set(s, o.toJSON()),
                            await Promise.all(t.map((async e => {
                                    if (e !== i)
                                        try {
                                            await e._remove(s)
                                        } catch (e) {
                                        }
                                }
                            ))),
                            new X(i, e, n)) : new X(i, e, n)
                    }
                }

                function Y(e) {
                    const t = e.toLowerCase();
                    if (t.includes("opera/") || t.includes("opr/") || t.includes("opios/"))
                        return "Opera";
                    if (te(t))
                        return "IEMobile";
                    if (t.includes("msie") || t.includes("trident/"))
                        return "IE";
                    if (t.includes("edge/"))
                        return "Edge";
                    if (Q(t))
                        return "Firefox";
                    if (t.includes("silk/"))
                        return "Silk";
                    if (re(t))
                        return "Blackberry";
                    if (ie(t))
                        return "Webos";
                    if (Z(t))
                        return "Safari";
                    if ((t.includes("chrome/") || ee(t)) && !t.includes("edge/"))
                        return "Chrome";
                    if (ne(t))
                        return "Android";
                    {
                        const t = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/
                            , n = e.match(t);
                        if (2 === (null == n ? void 0 : n.length))
                            return n[1]
                    }
                    return "Other"
                }

                function Q(e = (0,
                    r.z$)()) {
                    return /firefox\//i.test(e)
                }

                function Z(e = (0,
                    r.z$)()) {
                    const t = e.toLowerCase();
                    return t.includes("safari/") && !t.includes("chrome/") && !t.includes("crios/") && !t.includes("android")
                }

                function ee(e = (0,
                    r.z$)()) {
                    return /crios\//i.test(e)
                }

                function te(e = (0,
                    r.z$)()) {
                    return /iemobile/i.test(e)
                }

                function ne(e = (0,
                    r.z$)()) {
                    return /android/i.test(e)
                }

                function re(e = (0,
                    r.z$)()) {
                    return /blackberry/i.test(e)
                }

                function ie(e = (0,
                    r.z$)()) {
                    return /webos/i.test(e)
                }

                function se(e = (0,
                    r.z$)()) {
                    return /iphone|ipad|ipod/i.test(e) || /macintosh/i.test(e) && /mobile/i.test(e)
                }

                function oe(e = (0,
                    r.z$)()) {
                    return se(e) || ne(e) || ie(e) || re(e) || /windows phone/i.test(e) || te(e)
                }

                function ae(e, t = []) {
                    let n;
                    switch (e) {
                        case "Browser":
                            n = Y((0,
                                r.z$)());
                            break;
                        case "Worker":
                            n = `${Y((0,
                                r.z$)())}-${e}`;
                            break;
                        default:
                            n = e
                    }
                    const s = t.length ? t.join(",") : "FirebaseCore-web";
                    return `${n}/JsCore/${i.Jn}/${s}`
                }

                async function ce(e, t) {
                    return O(e, "GET", "/v2/recaptchaConfig", A(e, t))
                }

                function ue(e) {
                    return void 0 !== e && void 0 !== e.enterprise
                }

                class le {
                    constructor(e) {
                        if (this.siteKey = "",
                            this.emailPasswordEnabled = !1,
                        void 0 === e.recaptchaKey)
                            throw new Error("recaptchaKey undefined");
                        this.siteKey = e.recaptchaKey.split("/")[3],
                            this.emailPasswordEnabled = e.recaptchaEnforcementState.some((e => "EMAIL_PASSWORD_PROVIDER" === e.provider && "OFF" !== e.enforcementState))
                    }
                }

                function he(e) {
                    return new Promise(((t, n) => {
                            const r = document.createElement("script");
                            var i, s;
                            r.setAttribute("src", e),
                                r.onload = t,
                                r.onerror = e => {
                                    const t = p("internal-error");
                                    t.customData = e,
                                        n(t)
                                }
                                ,
                                r.type = "text/javascript",
                                r.charset = "UTF-8",
                                (null !== (s = null === (i = document.getElementsByTagName("head")) || void 0 === i ? void 0 : i[0]) && void 0 !== s ? s : document).appendChild(r)
                        }
                    ))
                }

                function de(e) {
                    return `__ ${e}${Math.floor(1e6 * Math.random())}`
                }

                class fe {
                    constructor(e) {
                        this.type = "recaptcha-enterprise",
                            this.auth = ve(e)
                    }

                    async verify(e = "verify", t = !1) {
                        function n(t, n, r) {
                            const i = window.grecaptcha;
                            ue(i) ? i.enterprise.ready((() => {
                                    i.enterprise.execute(t, {
                                        action: e
                                    }).then((e => {
                                            n(e)
                                        }
                                    )).catch((() => {
                                            n("NO_RECAPTCHA")
                                        }
                                    ))
                                }
                            )) : r(Error("No reCAPTCHA enterprise script loaded."))
                        }

                        return new Promise(((e, r) => {
                                (async function (e) {
                                        if (!t) {
                                            if (null == e.tenantId && null != e._agentRecaptchaConfig)
                                                return e._agentRecaptchaConfig.siteKey;
                                            if (null != e.tenantId && void 0 !== e._tenantRecaptchaConfigs[e.tenantId])
                                                return e._tenantRecaptchaConfigs[e.tenantId].siteKey
                                        }
                                        return new Promise((async (t, n) => {
                                                ce(e, {
                                                    clientType: "CLIENT_TYPE_WEB",
                                                    version: "RECAPTCHA_ENTERPRISE"
                                                }).then((r => {
                                                        if (void 0 !== r.recaptchaKey) {
                                                            const n = new le(r);
                                                            return null == e.tenantId ? e._agentRecaptchaConfig = n : e._tenantRecaptchaConfigs[e.tenantId] = n,
                                                                t(n.siteKey)
                                                        }
                                                        n(new Error("recaptcha Enterprise site key undefined"))
                                                    }
                                                )).catch((e => {
                                                        n(e)
                                                    }
                                                ))
                                            }
                                        ))
                                    }
                                )(this.auth).then((i => {
                                        if (!t && ue(window.grecaptcha))
                                            n(i, e, r);
                                        else {
                                            if ("undefined" == typeof window)
                                                return void r(new Error("RecaptchaVerifier is only supported in browser"));
                                            he("https://www.google.com/recaptcha/enterprise.js?render=" + i).then((() => {
                                                    n(i, e, r)
                                                }
                                            )).catch((e => {
                                                    r(e)
                                                }
                                            ))
                                        }
                                    }
                                )).catch((e => {
                                        r(e)
                                    }
                                ))
                            }
                        ))
                    }
                }

                async function pe(e, t, n, r = !1) {
                    const i = new fe(e);
                    let s;
                    try {
                        s = await i.verify(n)
                    } catch (e) {
                        s = await i.verify(n, !0)
                    }
                    const o = Object.assign({}, t);
                    return r ? Object.assign(o, {
                        captchaResp: s
                    }) : Object.assign(o, {
                        captchaResponse: s
                    }),
                        Object.assign(o, {
                            clientType: "CLIENT_TYPE_WEB"
                        }),
                        Object.assign(o, {
                            recaptchaVersion: "RECAPTCHA_ENTERPRISE"
                        }),
                        o
                }

                class me {
                    constructor(e) {
                        this.auth = e,
                            this.queue = []
                    }

                    pushCallback(e, t) {
                        const n = t => new Promise(((n, r) => {
                                try {
                                    n(e(t))
                                } catch (e) {
                                    r(e)
                                }
                            }
                        ));
                        n.onAbort = t,
                            this.queue.push(n);
                        const r = this.queue.length - 1;
                        return () => {
                            this.queue[r] = () => Promise.resolve()
                        }
                    }

                    async runMiddleware(e) {
                        if (this.auth.currentUser === e)
                            return;
                        const t = [];
                        try {
                            for (const n of this.queue)
                                await n(e),
                                n.onAbort && t.push(n.onAbort)
                        } catch (e) {
                            t.reverse();
                            for (const e of t)
                                try {
                                    e()
                                } catch (e) {
                                }
                            throw this.auth._errorFactory.create("login-blocked", {
                                originalMessage: null == e ? void 0 : e.message
                            })
                        }
                    }
                }

                class ge {
                    constructor(e, t, n, r) {
                        this.app = e,
                            this.heartbeatServiceProvider = t,
                            this.appCheckServiceProvider = n,
                            this.config = r,
                            this.currentUser = null,
                            this.emulatorConfig = null,
                            this.operations = Promise.resolve(),
                            this.authStateSubscription = new ye(this),
                            this.idTokenSubscription = new ye(this),
                            this.beforeStateQueue = new me(this),
                            this.redirectUser = null,
                            this.isProactiveRefreshEnabled = !1,
                            this._canInitEmulator = !0,
                            this._isInitialized = !1,
                            this._deleted = !1,
                            this._initializationPromise = null,
                            this._popupRedirectResolver = null,
                            this._errorFactory = l,
                            this._agentRecaptchaConfig = null,
                            this._tenantRecaptchaConfigs = {},
                            this.lastNotifiedUid = void 0,
                            this.languageCode = null,
                            this.tenantId = null,
                            this.settings = {
                                appVerificationDisabledForTesting: !1
                            },
                            this.frameworks = [],
                            this.name = e.name,
                            this.clientVersion = r.sdkClientVersion
                    }

                    _initializeWithPersistence(e, t) {
                        return t && (this._popupRedirectResolver = q(t)),
                            this._initializationPromise = this.queue((async () => {
                                    var n, r;
                                    if (!this._deleted && (this.persistenceManager = await X.create(this, e),
                                        !this._deleted)) {
                                        if (null === (n = this._popupRedirectResolver) || void 0 === n ? void 0 : n._shouldInitProactively)
                                            try {
                                                await this._popupRedirectResolver._initialize(this)
                                            } catch (e) {
                                            }
                                        await this.initializeCurrentUser(t),
                                            this.lastNotifiedUid = (null === (r = this.currentUser) || void 0 === r ? void 0 : r.uid) || null,
                                        this._deleted || (this._isInitialized = !0)
                                    }
                                }
                            )),
                            this._initializationPromise
                    }

                    async _onStorageEvent() {
                        if (this._deleted)
                            return;
                        const e = await this.assertedPersistence.getCurrentUser();
                        return this.currentUser || e ? this.currentUser && e && this.currentUser.uid === e.uid ? (this._currentUser._assign(e),
                            void await this.currentUser.getIdToken()) : void await this._updateCurrentUser(e, !0) : void 0
                    }

                    async initializeCurrentUser(e) {
                        var t;
                        const n = await this.assertedPersistence.getCurrentUser();
                        let r = n
                            , i = !1;
                        if (e && this.config.authDomain) {
                            await this.getOrInitRedirectPersistenceManager();
                            const n = null === (t = this.redirectUser) || void 0 === t ? void 0 : t._redirectEventId
                                , s = null == r ? void 0 : r._redirectEventId
                                , o = await this.tryRedirectSignIn(e);
                            n && n !== s || !(null == o ? void 0 : o.user) || (r = o.user,
                                i = !0)
                        }
                        if (!r)
                            return this.directlySetCurrentUser(null);
                        if (!r._redirectEventId) {
                            if (i)
                                try {
                                    await this.beforeStateQueue.runMiddleware(r)
                                } catch (e) {
                                    r = n,
                                        this._popupRedirectResolver._overrideRedirectResult(this, (() => Promise.reject(e)))
                                }
                            return r ? this.reloadAndSetCurrentUserOrClear(r) : this.directlySetCurrentUser(null)
                        }
                        return v(this._popupRedirectResolver, this, "argument-error"),
                            await this.getOrInitRedirectPersistenceManager(),
                            this.redirectUser && this.redirectUser._redirectEventId === r._redirectEventId ? this.directlySetCurrentUser(r) : this.reloadAndSetCurrentUserOrClear(r)
                    }

                    async tryRedirectSignIn(e) {
                        let t = null;
                        try {
                            t = await this._popupRedirectResolver._completeRedirectFn(this, e, !0)
                        } catch (e) {
                            await this._setRedirectUser(null)
                        }
                        return t
                    }

                    async reloadAndSetCurrentUserOrClear(e) {
                        try {
                            await z(e)
                        } catch (e) {
                            if ("auth/network-request-failed" !== (null == e ? void 0 : e.code))
                                return this.directlySetCurrentUser(null)
                        }
                        return this.directlySetCurrentUser(e)
                    }

                    useDeviceLanguage() {
                        this.languageCode = function () {
                            if ("undefined" == typeof navigator)
                                return null;
                            const e = navigator;
                            return e.languages && e.languages[0] || e.language || null
                        }()
                    }

                    async _delete() {
                        this._deleted = !0
                    }

                    async updateCurrentUser(e) {
                        const t = e ? (0,
                            r.m9)(e) : null;
                        return t && v(t.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"),
                            this._updateCurrentUser(t && t._clone(this))
                    }

                    async _updateCurrentUser(e, t = !1) {
                        if (!this._deleted)
                            return e && v(this.tenantId === e.tenantId, this, "tenant-id-mismatch"),
                            t || await this.beforeStateQueue.runMiddleware(e),
                                this.queue((async () => {
                                        await this.directlySetCurrentUser(e),
                                            this.notifyAuthListeners()
                                    }
                                ))
                    }

                    async signOut() {
                        return await this.beforeStateQueue.runMiddleware(null),
                        (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null),
                            this._updateCurrentUser(null, !0)
                    }

                    setPersistence(e) {
                        return this.queue((async () => {
                                await this.assertedPersistence.setPersistence(q(e))
                            }
                        ))
                    }

                    async initializeRecaptchaConfig() {
                        const e = await ce(this, {
                            clientType: "CLIENT_TYPE_WEB",
                            version: "RECAPTCHA_ENTERPRISE"
                        })
                            , t = new le(e);
                        if (null == this.tenantId ? this._agentRecaptchaConfig = t : this._tenantRecaptchaConfigs[this.tenantId] = t,
                            t.emailPasswordEnabled) {
                            new fe(this).verify()
                        }
                    }

                    _getRecaptchaConfig() {
                        return null == this.tenantId ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId]
                    }

                    _getPersistence() {
                        return this.assertedPersistence.persistence.type
                    }

                    _updateErrorMap(e) {
                        this._errorFactory = new r.LL("auth", "Firebase", e())
                    }

                    onAuthStateChanged(e, t, n) {
                        return this.registerStateListener(this.authStateSubscription, e, t, n)
                    }

                    beforeAuthStateChanged(e, t) {
                        return this.beforeStateQueue.pushCallback(e, t)
                    }

                    onIdTokenChanged(e, t, n) {
                        return this.registerStateListener(this.idTokenSubscription, e, t, n)
                    }

                    toJSON() {
                        var e;
                        return {
                            apiKey: this.config.apiKey,
                            authDomain: this.config.authDomain,
                            appName: this.name,
                            currentUser: null === (e = this._currentUser) || void 0 === e ? void 0 : e.toJSON()
                        }
                    }

                    async _setRedirectUser(e, t) {
                        const n = await this.getOrInitRedirectPersistenceManager(t);
                        return null === e ? n.removeCurrentUser() : n.setCurrentUser(e)
                    }

                    async getOrInitRedirectPersistenceManager(e) {
                        if (!this.redirectPersistenceManager) {
                            const t = e && q(e) || this._popupRedirectResolver;
                            v(t, this, "argument-error"),
                                this.redirectPersistenceManager = await X.create(this, [q(t._redirectPersistence)], "redirectUser"),
                                this.redirectUser = await this.redirectPersistenceManager.getCurrentUser()
                        }
                        return this.redirectPersistenceManager
                    }

                    async _redirectUserForId(e) {
                        var t, n;
                        return this._isInitialized && await this.queue((async () => {
                            }
                        )),
                            (null === (t = this._currentUser) || void 0 === t ? void 0 : t._redirectEventId) === e ? this._currentUser : (null === (n = this.redirectUser) || void 0 === n ? void 0 : n._redirectEventId) === e ? this.redirectUser : null
                    }

                    async _persistUserIfCurrent(e) {
                        if (e === this.currentUser)
                            return this.queue((async () => this.directlySetCurrentUser(e)))
                    }

                    _notifyListenersIfCurrent(e) {
                        e === this.currentUser && this.notifyAuthListeners()
                    }

                    _key() {
                        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`
                    }

                    _startProactiveRefresh() {
                        this.isProactiveRefreshEnabled = !0,
                        this.currentUser && this._currentUser._startProactiveRefresh()
                    }

                    _stopProactiveRefresh() {
                        this.isProactiveRefreshEnabled = !1,
                        this.currentUser && this._currentUser._stopProactiveRefresh()
                    }

                    get _currentUser() {
                        return this.currentUser
                    }

                    notifyAuthListeners() {
                        var e, t;
                        if (!this._isInitialized)
                            return;
                        this.idTokenSubscription.next(this.currentUser);
                        const n = null !== (t = null === (e = this.currentUser) || void 0 === e ? void 0 : e.uid) && void 0 !== t ? t : null;
                        this.lastNotifiedUid !== n && (this.lastNotifiedUid = n,
                            this.authStateSubscription.next(this.currentUser))
                    }

                    registerStateListener(e, t, n, r) {
                        if (this._deleted)
                            return () => {
                            }
                                ;
                        const i = "function" == typeof t ? t : t.next.bind(t)
                            , s = this._isInitialized ? Promise.resolve() : this._initializationPromise;
                        return v(s, this, "internal-error"),
                            s.then((() => i(this.currentUser))),
                            "function" == typeof t ? e.addObserver(t, n, r) : e.addObserver(t)
                    }

                    async directlySetCurrentUser(e) {
                        this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(),
                        e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(),
                            this.currentUser = e,
                            e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser()
                    }

                    queue(e) {
                        return this.operations = this.operations.then(e, e),
                            this.operations
                    }

                    get assertedPersistence() {
                        return v(this.persistenceManager, this, "internal-error"),
                            this.persistenceManager
                    }

                    _logFramework(e) {
                        e && !this.frameworks.includes(e) && (this.frameworks.push(e),
                            this.frameworks.sort(),
                            this.clientVersion = ae(this.config.clientPlatform, this._getFrameworks()))
                    }

                    _getFrameworks() {
                        return this.frameworks
                    }

                    async _getAdditionalHeaders() {
                        var e;
                        const t = {
                            "X-Client-Version": this.clientVersion
                        };
                        this.app.options.appId && (t["X-Firebase-gmpid"] = this.app.options.appId);
                        const n = await (null === (e = this.heartbeatServiceProvider.getImmediate({
                            optional: !0
                        })) || void 0 === e ? void 0 : e.getHeartbeatsHeader());
                        n && (t["X-Firebase-Client"] = n);
                        const r = await this._getAppCheckToken();
                        return r && (t["X-Firebase-AppCheck"] = r),
                            t
                    }

                    async _getAppCheckToken() {
                        var e;
                        const t = await (null === (e = this.appCheckServiceProvider.getImmediate({
                            optional: !0
                        })) || void 0 === e ? void 0 : e.getToken());
                        return (null == t ? void 0 : t.error) && function (e, ...t) {
                            h.logLevel <= o.in.WARN && h.warn(`Auth (${i.Jn}): ${e}`, ...t)
                        }(`Error while retrieving App Check token: ${t.error}`),
                            null == t ? void 0 : t.token
                    }
                }

                function ve(e) {
                    return (0,
                        r.m9)(e)
                }

                class ye {
                    constructor(e) {
                        this.auth = e,
                            this.observer = null,
                            this.addObserver = (0,
                                r.ne)((e => this.observer = e))
                    }

                    get next() {
                        return v(this.observer, this.auth, "internal-error"),
                            this.observer.next.bind(this.observer)
                    }
                }

                function we(e, t, n) {
                    const r = ve(e);
                    v(r._canInitEmulator, r, "emulator-config-failed"),
                        v(/^https?:\/\//.test(t), r, "invalid-emulator-scheme");
                    const i = !!(null == n ? void 0 : n.disableWarnings)
                        , s = _e(t)
                        , {host: o, port: a} = function (e) {
                        const t = _e(e)
                            , n = /(\/\/)?([^?#/]+)/.exec(e.substr(t.length));
                        if (!n)
                            return {
                                host: "",
                                port: null
                            };
                        const r = n[2].split("@").pop() || ""
                            , i = /^(\[[^\]]+\])(:|$)/.exec(r);
                        if (i) {
                            const e = i[1];
                            return {
                                host: e,
                                port: be(r.substr(e.length + 1))
                            }
                        }
                        {
                            const [e, t] = r.split(":");
                            return {
                                host: e,
                                port: be(t)
                            }
                        }
                    }(t)
                        , c = null === a ? "" : `:${a}`;
                    r.config.emulator = {
                        url: `${s}//${o}${c}/`
                    },
                        r.settings.appVerificationDisabledForTesting = !0,
                        r.emulatorConfig = Object.freeze({
                            host: o,
                            port: a,
                            protocol: s.replace(":", ""),
                            options: Object.freeze({
                                disableWarnings: i
                            })
                        }),
                    i || function () {
                        function e() {
                            const e = document.createElement("p")
                                , t = e.style;
                            e.innerText = "Running in emulator mode. Do not use with production credentials.",
                                t.position = "fixed",
                                t.width = "100%",
                                t.backgroundColor = "#ffffff",
                                t.border = ".1em solid #000000",
                                t.color = "#b50000",
                                t.bottom = "0px",
                                t.left = "0px",
                                t.margin = "0px",
                                t.zIndex = "10000",
                                t.textAlign = "center",
                                e.classList.add("firebase-emulator-warning"),
                                document.body.appendChild(e)
                        }

                        "undefined" != typeof console && "function" == typeof console.info && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");
                        "undefined" != typeof window && "undefined" != typeof document && ("loading" === document.readyState ? window.addEventListener("DOMContentLoaded", e) : e())
                    }()
                }

                function _e(e) {
                    const t = e.indexOf(":");
                    return t < 0 ? "" : e.substr(0, t + 1)
                }

                function be(e) {
                    if (!e)
                        return null;
                    const t = Number(e);
                    return isNaN(t) ? null : t
                }

                class Ie {
                    constructor(e, t) {
                        this.providerId = e,
                            this.signInMethod = t
                    }

                    toJSON() {
                        return y("not implemented")
                    }

                    _getIdTokenResponse(e) {
                        return y("not implemented")
                    }

                    _linkToIdToken(e, t) {
                        return y("not implemented")
                    }

                    _getReauthenticationResolver(e) {
                        return y("not implemented")
                    }
                }

                async function Te(e, t) {
                    return O(e, "POST", "/v1/accounts:update", t)
                }

                async function Ee(e, t) {
                    return P(e, "POST", "/v1/accounts:signInWithPassword", A(e, t))
                }

                class ke extends Ie {
                    constructor(e, t, n, r = null) {
                        super("password", n),
                            this._email = e,
                            this._password = t,
                            this._tenantId = r
                    }

                    static _fromEmailAndPassword(e, t) {
                        return new ke(e, t, "password")
                    }

                    static _fromEmailAndCode(e, t, n = null) {
                        return new ke(e, t, "emailLink", n)
                    }

                    toJSON() {
                        return {
                            email: this._email,
                            password: this._password,
                            signInMethod: this.signInMethod,
                            tenantId: this._tenantId
                        }
                    }

                    static fromJSON(e) {
                        const t = "string" == typeof e ? JSON.parse(e) : e;
                        if ((null == t ? void 0 : t.email) && (null == t ? void 0 : t.password)) {
                            if ("password" === t.signInMethod)
                                return this._fromEmailAndPassword(t.email, t.password);
                            if ("emailLink" === t.signInMethod)
                                return this._fromEmailAndCode(t.email, t.password, t.tenantId)
                        }
                        return null
                    }

                    async _getIdTokenResponse(e) {
                        var t;
                        switch (this.signInMethod) {
                            case "password":
                                const n = {
                                    returnSecureToken: !0,
                                    email: this._email,
                                    password: this._password,
                                    clientType: "CLIENT_TYPE_WEB"
                                };
                                if (null === (t = e._getRecaptchaConfig()) || void 0 === t ? void 0 : t.emailPasswordEnabled) {
                                    const t = await pe(e, n, "signInWithPassword");
                                    return Ee(e, t)
                                }
                                return Ee(e, n).catch((async t => {
                                        if ("auth/missing-recaptcha-token" === t.code) {
                                            console.log("Sign-in with email address and password is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-in flow.");
                                            const t = await pe(e, n, "signInWithPassword");
                                            return Ee(e, t)
                                        }
                                        return Promise.reject(t)
                                    }
                                ));
                            case "emailLink":
                                return async function (e, t) {
                                    return P(e, "POST", "/v1/accounts:signInWithEmailLink", A(e, t))
                                }(e, {
                                    email: this._email,
                                    oobCode: this._password
                                });
                            default:
                                f(e, "internal-error")
                        }
                    }

                    async _linkToIdToken(e, t) {
                        switch (this.signInMethod) {
                            case "password":
                                return Te(e, {
                                    idToken: t,
                                    returnSecureToken: !0,
                                    email: this._email,
                                    password: this._password
                                });
                            case "emailLink":
                                return async function (e, t) {
                                    return P(e, "POST", "/v1/accounts:signInWithEmailLink", A(e, t))
                                }(e, {
                                    idToken: t,
                                    email: this._email,
                                    oobCode: this._password
                                });
                            default:
                                f(e, "internal-error")
                        }
                    }

                    _getReauthenticationResolver(e) {
                        return this._getIdTokenResponse(e)
                    }
                }

                async function Se(e, t) {
                    return P(e, "POST", "/v1/accounts:signInWithIdp", A(e, t))
                }

                class Re extends Ie {
                    constructor() {
                        super(...arguments),
                            this.pendingToken = null
                    }

                    static _fromParams(e) {
                        const t = new Re(e.providerId, e.signInMethod);
                        return e.idToken || e.accessToken ? (e.idToken && (t.idToken = e.idToken),
                        e.accessToken && (t.accessToken = e.accessToken),
                        e.nonce && !e.pendingToken && (t.nonce = e.nonce),
                        e.pendingToken && (t.pendingToken = e.pendingToken)) : e.oauthToken && e.oauthTokenSecret ? (t.accessToken = e.oauthToken,
                            t.secret = e.oauthTokenSecret) : f("argument-error"),
                            t
                    }

                    toJSON() {
                        return {
                            idToken: this.idToken,
                            accessToken: this.accessToken,
                            secret: this.secret,
                            nonce: this.nonce,
                            pendingToken: this.pendingToken,
                            providerId: this.providerId,
                            signInMethod: this.signInMethod
                        }
                    }

                    static fromJSON(e) {
                        const t = "string" == typeof e ? JSON.parse(e) : e
                            , {providerId: n, signInMethod: r} = t
                            , i = s(t, ["providerId", "signInMethod"]);
                        if (!n || !r)
                            return null;
                        const o = new Re(n, r);
                        return o.idToken = i.idToken || void 0,
                            o.accessToken = i.accessToken || void 0,
                            o.secret = i.secret,
                            o.nonce = i.nonce,
                            o.pendingToken = i.pendingToken || null,
                            o
                    }

                    _getIdTokenResponse(e) {
                        return Se(e, this.buildRequest())
                    }

                    _linkToIdToken(e, t) {
                        const n = this.buildRequest();
                        return n.idToken = t,
                            Se(e, n)
                    }

                    _getReauthenticationResolver(e) {
                        const t = this.buildRequest();
                        return t.autoCreate = !1,
                            Se(e, t)
                    }

                    buildRequest() {
                        const e = {
                            requestUri: "http://localhost",
                            returnSecureToken: !0
                        };
                        if (this.pendingToken)
                            e.pendingToken = this.pendingToken;
                        else {
                            const t = {};
                            this.idToken && (t.id_token = this.idToken),
                            this.accessToken && (t.access_token = this.accessToken),
                            this.secret && (t.oauth_token_secret = this.secret),
                                t.providerId = this.providerId,
                            this.nonce && !this.pendingToken && (t.nonce = this.nonce),
                                e.postBody = (0,
                                    r.xO)(t)
                        }
                        return e
                    }
                }

                const Ae = {
                    USER_NOT_FOUND: "user-not-found"
                };

                class Oe extends Ie {
                    constructor(e) {
                        super("phone", "phone"),
                            this.params = e
                    }

                    static _fromVerification(e, t) {
                        return new Oe({
                            verificationId: e,
                            verificationCode: t
                        })
                    }

                    static _fromTokenResponse(e, t) {
                        return new Oe({
                            phoneNumber: e,
                            temporaryProof: t
                        })
                    }

                    _getIdTokenResponse(e) {
                        return async function (e, t) {
                            return P(e, "POST", "/v1/accounts:signInWithPhoneNumber", A(e, t))
                        }(e, this._makeVerificationRequest())
                    }

                    _linkToIdToken(e, t) {
                        return async function (e, t) {
                            const n = await P(e, "POST", "/v1/accounts:signInWithPhoneNumber", A(e, t));
                            if (n.temporaryProof)
                                throw L(e, "account-exists-with-different-credential", n);
                            return n
                        }(e, Object.assign({
                            idToken: t
                        }, this._makeVerificationRequest()))
                    }

                    _getReauthenticationResolver(e) {
                        return async function (e, t) {
                            return P(e, "POST", "/v1/accounts:signInWithPhoneNumber", A(e, Object.assign(Object.assign({}, t), {
                                operation: "REAUTH"
                            })), Ae)
                        }(e, this._makeVerificationRequest())
                    }

                    _makeVerificationRequest() {
                        const {temporaryProof: e, phoneNumber: t, verificationId: n, verificationCode: r} = this.params;
                        return e && t ? {
                            temporaryProof: e,
                            phoneNumber: t
                        } : {
                            sessionInfo: n,
                            code: r
                        }
                    }

                    toJSON() {
                        const e = {
                            providerId: this.providerId
                        };
                        return this.params.phoneNumber && (e.phoneNumber = this.params.phoneNumber),
                        this.params.temporaryProof && (e.temporaryProof = this.params.temporaryProof),
                        this.params.verificationCode && (e.verificationCode = this.params.verificationCode),
                        this.params.verificationId && (e.verificationId = this.params.verificationId),
                            e
                    }

                    static fromJSON(e) {
                        "string" == typeof e && (e = JSON.parse(e));
                        const {verificationId: t, verificationCode: n, phoneNumber: r, temporaryProof: i} = e;
                        return n || t || r || i ? new Oe({
                            verificationId: t,
                            verificationCode: n,
                            phoneNumber: r,
                            temporaryProof: i
                        }) : null
                    }
                }

                class Ce {
                    constructor(e) {
                        var t, n, i, s, o, a;
                        const c = (0,
                            r.zd)((0,
                            r.pd)(e))
                            , u = null !== (t = c.apiKey) && void 0 !== t ? t : null
                            , l = null !== (n = c.oobCode) && void 0 !== n ? n : null
                            , h = function (e) {
                            switch (e) {
                                case "recoverEmail":
                                    return "RECOVER_EMAIL";
                                case "resetPassword":
                                    return "PASSWORD_RESET";
                                case "signIn":
                                    return "EMAIL_SIGNIN";
                                case "verifyEmail":
                                    return "VERIFY_EMAIL";
                                case "verifyAndChangeEmail":
                                    return "VERIFY_AND_CHANGE_EMAIL";
                                case "revertSecondFactorAddition":
                                    return "REVERT_SECOND_FACTOR_ADDITION";
                                default:
                                    return null
                            }
                        }(null !== (i = c.mode) && void 0 !== i ? i : null);
                        v(u && l && h, "argument-error"),
                            this.apiKey = u,
                            this.operation = h,
                            this.code = l,
                            this.continueUrl = null !== (s = c.continueUrl) && void 0 !== s ? s : null,
                            this.languageCode = null !== (o = c.languageCode) && void 0 !== o ? o : null,
                            this.tenantId = null !== (a = c.tenantId) && void 0 !== a ? a : null
                    }

                    static parseLink(e) {
                        const t = function (e) {
                            const t = (0,
                                r.zd)((0,
                                r.pd)(e)).link
                                , n = t ? (0,
                                r.zd)((0,
                                r.pd)(t)).deep_link_id : null
                                , i = (0,
                                r.zd)((0,
                                r.pd)(e)).deep_link_id;
                            return (i ? (0,
                                r.zd)((0,
                                r.pd)(i)).link : null) || i || n || t || e
                        }(e);
                        try {
                            return new Ce(t)
                        } catch (e) {
                            return null
                        }
                    }
                }

                class Pe {
                    constructor() {
                        this.providerId = Pe.PROVIDER_ID
                    }

                    static credential(e, t) {
                        return ke._fromEmailAndPassword(e, t)
                    }

                    static credentialWithLink(e, t) {
                        const n = Ce.parseLink(t);
                        return v(n, "argument-error"),
                            ke._fromEmailAndCode(e, n.code, n.tenantId)
                    }
                }

                Pe.PROVIDER_ID = "password",
                    Pe.EMAIL_PASSWORD_SIGN_IN_METHOD = "password",
                    Pe.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";

                class Ne {
                    constructor(e) {
                        this.providerId = e,
                            this.defaultLanguageCode = null,
                            this.customParameters = {}
                    }

                    setDefaultLanguage(e) {
                        this.defaultLanguageCode = e
                    }

                    setCustomParameters(e) {
                        return this.customParameters = e,
                            this
                    }

                    getCustomParameters() {
                        return this.customParameters
                    }
                }

                class De extends Ne {
                    constructor() {
                        super(...arguments),
                            this.scopes = []
                    }

                    addScope(e) {
                        return this.scopes.includes(e) || this.scopes.push(e),
                            this
                    }

                    getScopes() {
                        return [...this.scopes]
                    }
                }

                class Le extends De {
                    constructor() {
                        super("facebook.com")
                    }

                    static credential(e) {
                        return Re._fromParams({
                            providerId: Le.PROVIDER_ID,
                            signInMethod: Le.FACEBOOK_SIGN_IN_METHOD,
                            accessToken: e
                        })
                    }

                    static credentialFromResult(e) {
                        return Le.credentialFromTaggedObject(e)
                    }

                    static credentialFromError(e) {
                        return Le.credentialFromTaggedObject(e.customData || {})
                    }

                    static credentialFromTaggedObject({_tokenResponse: e}) {
                        if (!e || !("oauthAccessToken" in e))
                            return null;
                        if (!e.oauthAccessToken)
                            return null;
                        try {
                            return Le.credential(e.oauthAccessToken)
                        } catch (e) {
                            return null
                        }
                    }
                }

                Le.FACEBOOK_SIGN_IN_METHOD = "facebook.com",
                    Le.PROVIDER_ID = "facebook.com";

                class Me extends De {
                    constructor() {
                        super("google.com"),
                            this.addScope("profile")
                    }

                    static credential(e, t) {
                        return Re._fromParams({
                            providerId: Me.PROVIDER_ID,
                            signInMethod: Me.GOOGLE_SIGN_IN_METHOD,
                            idToken: e,
                            accessToken: t
                        })
                    }

                    static credentialFromResult(e) {
                        return Me.credentialFromTaggedObject(e)
                    }

                    static credentialFromError(e) {
                        return Me.credentialFromTaggedObject(e.customData || {})
                    }

                    static credentialFromTaggedObject({_tokenResponse: e}) {
                        if (!e)
                            return null;
                        const {oauthIdToken: t, oauthAccessToken: n} = e;
                        if (!t && !n)
                            return null;
                        try {
                            return Me.credential(t, n)
                        } catch (e) {
                            return null
                        }
                    }
                }

                Me.GOOGLE_SIGN_IN_METHOD = "google.com",
                    Me.PROVIDER_ID = "google.com";

                class Ue extends De {
                    constructor() {
                        super("github.com")
                    }

                    static credential(e) {
                        return Re._fromParams({
                            providerId: Ue.PROVIDER_ID,
                            signInMethod: Ue.GITHUB_SIGN_IN_METHOD,
                            accessToken: e
                        })
                    }

                    static credentialFromResult(e) {
                        return Ue.credentialFromTaggedObject(e)
                    }

                    static credentialFromError(e) {
                        return Ue.credentialFromTaggedObject(e.customData || {})
                    }

                    static credentialFromTaggedObject({_tokenResponse: e}) {
                        if (!e || !("oauthAccessToken" in e))
                            return null;
                        if (!e.oauthAccessToken)
                            return null;
                        try {
                            return Ue.credential(e.oauthAccessToken)
                        } catch (e) {
                            return null
                        }
                    }
                }

                Ue.GITHUB_SIGN_IN_METHOD = "github.com",
                    Ue.PROVIDER_ID = "github.com";

                class xe extends De {
                    constructor() {
                        super("twitter.com")
                    }

                    static credential(e, t) {
                        return Re._fromParams({
                            providerId: xe.PROVIDER_ID,
                            signInMethod: xe.TWITTER_SIGN_IN_METHOD,
                            oauthToken: e,
                            oauthTokenSecret: t
                        })
                    }

                    static credentialFromResult(e) {
                        return xe.credentialFromTaggedObject(e)
                    }

                    static credentialFromError(e) {
                        return xe.credentialFromTaggedObject(e.customData || {})
                    }

                    static credentialFromTaggedObject({_tokenResponse: e}) {
                        if (!e)
                            return null;
                        const {oauthAccessToken: t, oauthTokenSecret: n} = e;
                        if (!t || !n)
                            return null;
                        try {
                            return xe.credential(t, n)
                        } catch (e) {
                            return null
                        }
                    }
                }

                xe.TWITTER_SIGN_IN_METHOD = "twitter.com",
                    xe.PROVIDER_ID = "twitter.com";

                class Fe {
                    constructor(e) {
                        this.user = e.user,
                            this.providerId = e.providerId,
                            this._tokenResponse = e._tokenResponse,
                            this.operationType = e.operationType
                    }

                    static async _fromIdTokenResponse(e, t, n, r = !1) {
                        const i = await H._fromIdTokenResponse(e, n, r)
                            , s = Ve(n);
                        return new Fe({
                            user: i,
                            providerId: s,
                            _tokenResponse: n,
                            operationType: t
                        })
                    }

                    static async _forOperation(e, t, n) {
                        await e._updateTokensIfNecessary(n, !0);
                        const r = Ve(n);
                        return new Fe({
                            user: e,
                            providerId: r,
                            _tokenResponse: n,
                            operationType: t
                        })
                    }
                }

                function Ve(e) {
                    return e.providerId ? e.providerId : "phoneNumber" in e ? "phone" : null
                }

                class je extends r.ZR {
                    constructor(e, t, n, r) {
                        var i;
                        super(t.code, t.message),
                            this.operationType = n,
                            this.user = r,
                            Object.setPrototypeOf(this, je.prototype),
                            this.customData = {
                                appName: e.name,
                                tenantId: null !== (i = e.tenantId) && void 0 !== i ? i : void 0,
                                _serverResponse: t.customData._serverResponse,
                                operationType: n
                            }
                    }

                    static _fromErrorAndOperation(e, t, n, r) {
                        return new je(e, t, n, r)
                    }
                }

                function ze(e, t, n, r) {
                    return ("reauthenticate" === t ? n._getReauthenticationResolver(e) : n._getIdTokenResponse(e)).catch((n => {
                            if ("auth/multi-factor-auth-required" === n.code)
                                throw je._fromErrorAndOperation(e, n, t, r);
                            throw n
                        }
                    ))
                }

                async function $e(e, t, n = !1) {
                    const r = await F(e, t._linkToIdToken(e.auth, await e.getIdToken()), n);
                    return Fe._forOperation(e, "link", r)
                }

                async function Be(e, t, n = !1) {
                    const {auth: r} = e
                        , i = "reauthenticate";
                    try {
                        const s = await F(e, ze(r, i, t, e), n);
                        v(s.idToken, r, "internal-error");
                        const o = x(s.idToken);
                        v(o, r, "internal-error");
                        const {sub: a} = o;
                        return v(e.uid === a, r, "user-mismatch"),
                            Fe._forOperation(e, i, s)
                    } catch (e) {
                        throw "auth/user-not-found" === (null == e ? void 0 : e.code) && f(r, "user-mismatch"),
                            e
                    }
                }

                async function He(e, t, n = !1) {
                    const r = "signIn"
                        , i = await ze(e, r, t)
                        , s = await Fe._fromIdTokenResponse(e, r, i);
                    return n || await e._updateCurrentUser(s.user),
                        s
                }

                async function We(e, t) {
                    const n = ve(e)
                        , r = await async function (e, t) {
                        return P(e, "POST", "/v1/accounts:signInWithCustomToken", A(e, t))
                    }(n, {
                        token: t,
                        returnSecureToken: !0
                    })
                        , i = await Fe._fromIdTokenResponse(n, "signIn", r);
                    return await n._updateCurrentUser(i.user),
                        i
                }

                function qe(e, t, n, i) {
                    return (0,
                        r.m9)(e).onAuthStateChanged(t, n, i)
                }

                new WeakMap;
                const Ke = "__sak";

                class Je {
                    constructor(e, t) {
                        this.storageRetriever = e,
                            this.type = t
                    }

                    _isAvailable() {
                        try {
                            return this.storage ? (this.storage.setItem(Ke, "1"),
                                this.storage.removeItem(Ke),
                                Promise.resolve(!0)) : Promise.resolve(!1)
                        } catch (e) {
                            return Promise.resolve(!1)
                        }
                    }

                    _set(e, t) {
                        return this.storage.setItem(e, JSON.stringify(t)),
                            Promise.resolve()
                    }

                    _get(e) {
                        const t = this.storage.getItem(e);
                        return Promise.resolve(t ? JSON.parse(t) : null)
                    }

                    _remove(e) {
                        return this.storage.removeItem(e),
                            Promise.resolve()
                    }

                    get storage() {
                        return this.storageRetriever()
                    }
                }

                class Ge extends Je {
                    constructor() {
                        super((() => window.localStorage), "LOCAL"),
                            this.boundEventHandler = (e, t) => this.onStorageEvent(e, t),
                            this.listeners = {},
                            this.localCache = {},
                            this.pollTimer = null,
                            this.safariLocalStorageNotSynced = function () {
                                const e = (0,
                                    r.z$)();
                                return Z(e) || se(e)
                            }() && function () {
                                try {
                                    return !(!window || window === window.top)
                                } catch (e) {
                                    return !1
                                }
                            }(),
                            this.fallbackToPolling = oe(),
                            this._shouldAllowMigration = !0
                    }

                    forAllChangedKeys(e) {
                        for (const t of Object.keys(this.listeners)) {
                            const n = this.storage.getItem(t)
                                , r = this.localCache[t];
                            n !== r && e(t, r, n)
                        }
                    }

                    onStorageEvent(e, t = !1) {
                        if (!e.key)
                            return void this.forAllChangedKeys(((e, t, n) => {
                                    this.notifyListeners(e, n)
                                }
                            ));
                        const n = e.key;
                        if (t ? this.detachListener() : this.stopPolling(),
                            this.safariLocalStorageNotSynced) {
                            const r = this.storage.getItem(n);
                            if (e.newValue !== r)
                                null !== e.newValue ? this.storage.setItem(n, e.newValue) : this.storage.removeItem(n);
                            else if (this.localCache[n] === e.newValue && !t)
                                return
                        }
                        const i = () => {
                            const e = this.storage.getItem(n);
                            (t || this.localCache[n] !== e) && this.notifyListeners(n, e)
                        }
                            , s = this.storage.getItem(n);
                        (0,
                            r.w1)() && 10 === document.documentMode && s !== e.newValue && e.newValue !== e.oldValue ? setTimeout(i, 10) : i()
                    }

                    notifyListeners(e, t) {
                        this.localCache[e] = t;
                        const n = this.listeners[e];
                        if (n)
                            for (const e of Array.from(n))
                                e(t ? JSON.parse(t) : t)
                    }

                    startPolling() {
                        this.stopPolling(),
                            this.pollTimer = setInterval((() => {
                                    this.forAllChangedKeys(((e, t, n) => {
                                            this.onStorageEvent(new StorageEvent("storage", {
                                                key: e,
                                                oldValue: t,
                                                newValue: n
                                            }), !0)
                                        }
                                    ))
                                }
                            ), 1e3)
                    }

                    stopPolling() {
                        this.pollTimer && (clearInterval(this.pollTimer),
                            this.pollTimer = null)
                    }

                    attachListener() {
                        window.addEventListener("storage", this.boundEventHandler)
                    }

                    detachListener() {
                        window.removeEventListener("storage", this.boundEventHandler)
                    }

                    _addListener(e, t) {
                        0 === Object.keys(this.listeners).length && (this.fallbackToPolling ? this.startPolling() : this.attachListener()),
                        this.listeners[e] || (this.listeners[e] = new Set,
                            this.localCache[e] = this.storage.getItem(e)),
                            this.listeners[e].add(t)
                    }

                    _removeListener(e, t) {
                        this.listeners[e] && (this.listeners[e].delete(t),
                        0 === this.listeners[e].size && delete this.listeners[e]),
                        0 === Object.keys(this.listeners).length && (this.detachListener(),
                            this.stopPolling())
                    }

                    async _set(e, t) {
                        await super._set(e, t),
                            this.localCache[e] = JSON.stringify(t)
                    }

                    async _get(e) {
                        const t = await super._get(e);
                        return this.localCache[e] = JSON.stringify(t),
                            t
                    }

                    async _remove(e) {
                        await super._remove(e),
                            delete this.localCache[e]
                    }
                }

                Ge.type = "LOCAL";
                const Xe = Ge;

                class Ye extends Je {
                    constructor() {
                        super((() => window.sessionStorage), "SESSION")
                    }

                    _addListener(e, t) {
                    }

                    _removeListener(e, t) {
                    }
                }

                Ye.type = "SESSION";
                const Qe = Ye;

                class Ze {
                    constructor(e) {
                        this.eventTarget = e,
                            this.handlersMap = {},
                            this.boundEventHandler = this.handleEvent.bind(this)
                    }

                    static _getInstance(e) {
                        const t = this.receivers.find((t => t.isListeningto(e)));
                        if (t)
                            return t;
                        const n = new Ze(e);
                        return this.receivers.push(n),
                            n
                    }

                    isListeningto(e) {
                        return this.eventTarget === e
                    }

                    async handleEvent(e) {
                        const t = e
                            , {eventId: n, eventType: r, data: i} = t.data
                            , s = this.handlersMap[r];
                        if (!(null == s ? void 0 : s.size))
                            return;
                        t.ports[0].postMessage({
                            status: "ack",
                            eventId: n,
                            eventType: r
                        });
                        const o = Array.from(s).map((async e => e(t.origin, i)))
                            , a = await function (e) {
                            return Promise.all(e.map((async e => {
                                    try {
                                        return {
                                            fulfilled: !0,
                                            value: await e
                                        }
                                    } catch (e) {
                                        return {
                                            fulfilled: !1,
                                            reason: e
                                        }
                                    }
                                }
                            )))
                        }(o);
                        t.ports[0].postMessage({
                            status: "done",
                            eventId: n,
                            eventType: r,
                            response: a
                        })
                    }

                    _subscribe(e, t) {
                        0 === Object.keys(this.handlersMap).length && this.eventTarget.addEventListener("message", this.boundEventHandler),
                        this.handlersMap[e] || (this.handlersMap[e] = new Set),
                            this.handlersMap[e].add(t)
                    }

                    _unsubscribe(e, t) {
                        this.handlersMap[e] && t && this.handlersMap[e].delete(t),
                        t && 0 !== this.handlersMap[e].size || delete this.handlersMap[e],
                        0 === Object.keys(this.handlersMap).length && this.eventTarget.removeEventListener("message", this.boundEventHandler)
                    }
                }

                function et(e = "", t = 10) {
                    let n = "";
                    for (let e = 0; e < t; e++)
                        n += Math.floor(10 * Math.random());
                    return e + n
                }

                Ze.receivers = [];

                class tt {
                    constructor(e) {
                        this.target = e,
                            this.handlers = new Set
                    }

                    removeMessageHandler(e) {
                        e.messageChannel && (e.messageChannel.port1.removeEventListener("message", e.onMessage),
                            e.messageChannel.port1.close()),
                            this.handlers.delete(e)
                    }

                    async _send(e, t, n = 50) {
                        const r = "undefined" != typeof MessageChannel ? new MessageChannel : null;
                        if (!r)
                            throw new Error("connection_unavailable");
                        let i, s;
                        return new Promise(((o, a) => {
                                const c = et("", 20);
                                r.port1.start();
                                const u = setTimeout((() => {
                                        a(new Error("unsupported_event"))
                                    }
                                ), n);
                                s = {
                                    messageChannel: r,
                                    onMessage(e) {
                                        const t = e;
                                        if (t.data.eventId === c)
                                            switch (t.data.status) {
                                                case "ack":
                                                    clearTimeout(u),
                                                        i = setTimeout((() => {
                                                                a(new Error("timeout"))
                                                            }
                                                        ), 3e3);
                                                    break;
                                                case "done":
                                                    clearTimeout(i),
                                                        o(t.data.response);
                                                    break;
                                                default:
                                                    clearTimeout(u),
                                                        clearTimeout(i),
                                                        a(new Error("invalid_response"))
                                            }
                                    }
                                },
                                    this.handlers.add(s),
                                    r.port1.addEventListener("message", s.onMessage),
                                    this.target.postMessage({
                                        eventType: e,
                                        eventId: c,
                                        data: t
                                    }, [r.port2])
                            }
                        )).finally((() => {
                                s && this.removeMessageHandler(s)
                            }
                        ))
                    }
                }

                function nt() {
                    return window
                }

                function rt() {
                    return void 0 !== nt().WorkerGlobalScope && "function" == typeof nt().importScripts
                }

                const it = "firebaseLocalStorageDb"
                    , st = "firebaseLocalStorage"
                    , ot = "fbase_key";

                class at {
                    constructor(e) {
                        this.request = e
                    }

                    toPromise() {
                        return new Promise(((e, t) => {
                                this.request.addEventListener("success", (() => {
                                        e(this.request.result)
                                    }
                                )),
                                    this.request.addEventListener("error", (() => {
                                            t(this.request.error)
                                        }
                                    ))
                            }
                        ))
                    }
                }

                function ct(e, t) {
                    return e.transaction([st], t ? "readwrite" : "readonly").objectStore(st)
                }

                function ut() {
                    const e = indexedDB.open(it, 1);
                    return new Promise(((t, n) => {
                            e.addEventListener("error", (() => {
                                    n(e.error)
                                }
                            )),
                                e.addEventListener("upgradeneeded", (() => {
                                        const t = e.result;
                                        try {
                                            t.createObjectStore(st, {
                                                keyPath: ot
                                            })
                                        } catch (e) {
                                            n(e)
                                        }
                                    }
                                )),
                                e.addEventListener("success", (async () => {
                                        const n = e.result;
                                        n.objectStoreNames.contains(st) ? t(n) : (n.close(),
                                            await function () {
                                                const e = indexedDB.deleteDatabase(it);
                                                return new at(e).toPromise()
                                            }(),
                                            t(await ut()))
                                    }
                                ))
                        }
                    ))
                }

                async function lt(e, t, n) {
                    const r = ct(e, !0).put({
                        [ot]: t,
                        value: n
                    });
                    return new at(r).toPromise()
                }

                function ht(e, t) {
                    const n = ct(e, !0).delete(t);
                    return new at(n).toPromise()
                }

                class dt {
                    constructor() {
                        this.type = "LOCAL",
                            this._shouldAllowMigration = !0,
                            this.listeners = {},
                            this.localCache = {},
                            this.pollTimer = null,
                            this.pendingWrites = 0,
                            this.receiver = null,
                            this.sender = null,
                            this.serviceWorkerReceiverAvailable = !1,
                            this.activeServiceWorker = null,
                            this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then((() => {
                                }
                            ), (() => {
                                }
                            ))
                    }

                    async _openDb() {
                        return this.db || (this.db = await ut()),
                            this.db
                    }

                    async _withRetries(e) {
                        let t = 0;
                        for (; ;)
                            try {
                                const t = await this._openDb();
                                return await e(t)
                            } catch (e) {
                                if (t++ > 3)
                                    throw e;
                                this.db && (this.db.close(),
                                    this.db = void 0)
                            }
                    }

                    async initializeServiceWorkerMessaging() {
                        return rt() ? this.initializeReceiver() : this.initializeSender()
                    }

                    async initializeReceiver() {
                        this.receiver = Ze._getInstance(rt() ? self : null),
                            this.receiver._subscribe("keyChanged", (async (e, t) => ({
                                keyProcessed: (await this._poll()).includes(t.key)
                            }))),
                            this.receiver._subscribe("ping", (async (e, t) => ["keyChanged"]))
                    }

                    async initializeSender() {
                        var e, t;
                        if (this.activeServiceWorker = await async function () {
                            if (!(null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker))
                                return null;
                            try {
                                return (await navigator.serviceWorker.ready).active
                            } catch (e) {
                                return null
                            }
                        }(),
                            !this.activeServiceWorker)
                            return;
                        this.sender = new tt(this.activeServiceWorker);
                        const n = await this.sender._send("ping", {}, 800);
                        n && (null === (e = n[0]) || void 0 === e ? void 0 : e.fulfilled) && (null === (t = n[0]) || void 0 === t ? void 0 : t.value.includes("keyChanged")) && (this.serviceWorkerReceiverAvailable = !0)
                    }

                    async notifyServiceWorker(e) {
                        var t;
                        if (this.sender && this.activeServiceWorker && ((null === (t = null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker) || void 0 === t ? void 0 : t.controller) || null) === this.activeServiceWorker)
                            try {
                                await this.sender._send("keyChanged", {
                                    key: e
                                }, this.serviceWorkerReceiverAvailable ? 800 : 50)
                            } catch (t) {
                            }
                    }

                    async _isAvailable() {
                        try {
                            if (!indexedDB)
                                return !1;
                            const e = await ut();
                            return await lt(e, Ke, "1"),
                                await ht(e, Ke),
                                !0
                        } catch (e) {
                        }
                        return !1
                    }

                    async _withPendingWrite(e) {
                        this.pendingWrites++;
                        try {
                            await e()
                        } finally {
                            this.pendingWrites--
                        }
                    }

                    async _set(e, t) {
                        return this._withPendingWrite((async () => (await this._withRetries((n => lt(n, e, t))),
                            this.localCache[e] = t,
                            this.notifyServiceWorker(e))))
                    }

                    async _get(e) {
                        const t = await this._withRetries((t => async function (e, t) {
                            const n = ct(e, !1).get(t)
                                , r = await new at(n).toPromise();
                            return void 0 === r ? null : r.value
                        }(t, e)));
                        return this.localCache[e] = t,
                            t
                    }

                    async _remove(e) {
                        return this._withPendingWrite((async () => (await this._withRetries((t => ht(t, e))),
                            delete this.localCache[e],
                            this.notifyServiceWorker(e))))
                    }

                    async _poll() {
                        const e = await this._withRetries((e => {
                                const t = ct(e, !1).getAll();
                                return new at(t).toPromise()
                            }
                        ));
                        if (!e)
                            return [];
                        if (0 !== this.pendingWrites)
                            return [];
                        const t = []
                            , n = new Set;
                        for (const {fbase_key: r, value: i} of e)
                            n.add(r),
                            JSON.stringify(this.localCache[r]) !== JSON.stringify(i) && (this.notifyListeners(r, i),
                                t.push(r));
                        for (const e of Object.keys(this.localCache))
                            this.localCache[e] && !n.has(e) && (this.notifyListeners(e, null),
                                t.push(e));
                        return t
                    }

                    notifyListeners(e, t) {
                        this.localCache[e] = t;
                        const n = this.listeners[e];
                        if (n)
                            for (const e of Array.from(n))
                                e(t)
                    }

                    startPolling() {
                        this.stopPolling(),
                            this.pollTimer = setInterval((async () => this._poll()), 800)
                    }

                    stopPolling() {
                        this.pollTimer && (clearInterval(this.pollTimer),
                            this.pollTimer = null)
                    }

                    _addListener(e, t) {
                        0 === Object.keys(this.listeners).length && this.startPolling(),
                        this.listeners[e] || (this.listeners[e] = new Set,
                            this._get(e)),
                            this.listeners[e].add(t)
                    }

                    _removeListener(e, t) {
                        this.listeners[e] && (this.listeners[e].delete(t),
                        0 === this.listeners[e].size && delete this.listeners[e]),
                        0 === Object.keys(this.listeners).length && this.stopPolling()
                    }
                }

                dt.type = "LOCAL";
                const ft = dt;
                de("rcb"),
                    new T(3e4, 6e4);
                const pt = "recaptcha";

                async function mt(e, t, n) {
                    var r;
                    const i = await n.verify();
                    try {
                        let s;
                        if (v("string" == typeof i, e, "argument-error"),
                            v(n.type === pt, e, "argument-error"),
                            s = "string" == typeof t ? {
                                phoneNumber: t
                            } : t,
                        "session" in s) {
                            const t = s.session;
                            if ("phoneNumber" in s) {
                                v("enroll" === t.type, e, "internal-error");
                                const n = await function (e, t) {
                                    return O(e, "POST", "/v2/accounts/mfaEnrollment:start", A(e, t))
                                }(e, {
                                    idToken: t.credential,
                                    phoneEnrollmentInfo: {
                                        phoneNumber: s.phoneNumber,
                                        recaptchaToken: i
                                    }
                                });
                                return n.phoneSessionInfo.sessionInfo
                            }
                            {
                                v("signin" === t.type, e, "internal-error");
                                const n = (null === (r = s.multiFactorHint) || void 0 === r ? void 0 : r.uid) || s.multiFactorUid;
                                v(n, e, "missing-multi-factor-info");
                                const o = await function (e, t) {
                                    return O(e, "POST", "/v2/accounts/mfaSignIn:start", A(e, t))
                                }(e, {
                                    mfaPendingCredential: t.credential,
                                    mfaEnrollmentId: n,
                                    phoneSignInInfo: {
                                        recaptchaToken: i
                                    }
                                });
                                return o.phoneResponseInfo.sessionInfo
                            }
                        }
                        {
                            const {sessionInfo: t} = await async function (e, t) {
                                return O(e, "POST", "/v1/accounts:sendVerificationCode", A(e, t))
                            }(e, {
                                phoneNumber: s.phoneNumber,
                                recaptchaToken: i
                            });
                            return t
                        }
                    } finally {
                        n._reset()
                    }
                }

                class gt {
                    constructor(e) {
                        this.providerId = gt.PROVIDER_ID,
                            this.auth = ve(e)
                    }

                    verifyPhoneNumber(e, t) {
                        return mt(this.auth, e, (0,
                            r.m9)(t))
                    }

                    static credential(e, t) {
                        return Oe._fromVerification(e, t)
                    }

                    static credentialFromResult(e) {
                        const t = e;
                        return gt.credentialFromTaggedObject(t)
                    }

                    static credentialFromError(e) {
                        return gt.credentialFromTaggedObject(e.customData || {})
                    }

                    static credentialFromTaggedObject({_tokenResponse: e}) {
                        if (!e)
                            return null;
                        const {phoneNumber: t, temporaryProof: n} = e;
                        return t && n ? Oe._fromTokenResponse(t, n) : null
                    }
                }

                function vt(e, t) {
                    return t ? q(t) : (v(e._popupRedirectResolver, e, "argument-error"),
                        e._popupRedirectResolver)
                }

                gt.PROVIDER_ID = "phone",
                    gt.PHONE_SIGN_IN_METHOD = "phone";

                class yt extends Ie {
                    constructor(e) {
                        super("custom", "custom"),
                            this.params = e
                    }

                    _getIdTokenResponse(e) {
                        return Se(e, this._buildIdpRequest())
                    }

                    _linkToIdToken(e, t) {
                        return Se(e, this._buildIdpRequest(t))
                    }

                    _getReauthenticationResolver(e) {
                        return Se(e, this._buildIdpRequest())
                    }

                    _buildIdpRequest(e) {
                        const t = {
                            requestUri: this.params.requestUri,
                            sessionId: this.params.sessionId,
                            postBody: this.params.postBody,
                            tenantId: this.params.tenantId,
                            pendingToken: this.params.pendingToken,
                            returnSecureToken: !0,
                            returnIdpCredential: !0
                        };
                        return e && (t.idToken = e),
                            t
                    }
                }

                function wt(e) {
                    return He(e.auth, new yt(e), e.bypassAuthState)
                }

                function _t(e) {
                    const {auth: t, user: n} = e;
                    return v(n, t, "internal-error"),
                        Be(n, new yt(e), e.bypassAuthState)
                }

                async function bt(e) {
                    const {auth: t, user: n} = e;
                    return v(n, t, "internal-error"),
                        $e(n, new yt(e), e.bypassAuthState)
                }

                class It {
                    constructor(e, t, n, r, i = !1) {
                        this.auth = e,
                            this.resolver = n,
                            this.user = r,
                            this.bypassAuthState = i,
                            this.pendingPromise = null,
                            this.eventManager = null,
                            this.filter = Array.isArray(t) ? t : [t]
                    }

                    execute() {
                        return new Promise((async (e, t) => {
                                this.pendingPromise = {
                                    resolve: e,
                                    reject: t
                                };
                                try {
                                    this.eventManager = await this.resolver._initialize(this.auth),
                                        await this.onExecution(),
                                        this.eventManager.registerConsumer(this)
                                } catch (e) {
                                    this.reject(e)
                                }
                            }
                        ))
                    }

                    async onAuthEvent(e) {
                        const {urlResponse: t, sessionId: n, postBody: r, tenantId: i, error: s, type: o} = e;
                        if (s)
                            return void this.reject(s);
                        const a = {
                            auth: this.auth,
                            requestUri: t,
                            sessionId: n,
                            tenantId: i || void 0,
                            postBody: r || void 0,
                            user: this.user,
                            bypassAuthState: this.bypassAuthState
                        };
                        try {
                            this.resolve(await this.getIdpTask(o)(a))
                        } catch (e) {
                            this.reject(e)
                        }
                    }

                    onError(e) {
                        this.reject(e)
                    }

                    getIdpTask(e) {
                        switch (e) {
                            case "signInViaPopup":
                            case "signInViaRedirect":
                                return wt;
                            case "linkViaPopup":
                            case "linkViaRedirect":
                                return bt;
                            case "reauthViaPopup":
                            case "reauthViaRedirect":
                                return _t;
                            default:
                                f(this.auth, "internal-error")
                        }
                    }

                    resolve(e) {
                        w(this.pendingPromise, "Pending promise was never set"),
                            this.pendingPromise.resolve(e),
                            this.unregisterAndCleanUp()
                    }

                    reject(e) {
                        w(this.pendingPromise, "Pending promise was never set"),
                            this.pendingPromise.reject(e),
                            this.unregisterAndCleanUp()
                    }

                    unregisterAndCleanUp() {
                        this.eventManager && this.eventManager.unregisterConsumer(this),
                            this.pendingPromise = null,
                            this.cleanUp()
                    }
                }

                const Tt = new T(2e3, 1e4);

                class Et extends It {
                    constructor(e, t, n, r, i) {
                        super(e, t, r, i),
                            this.provider = n,
                            this.authWindow = null,
                            this.pollId = null,
                        Et.currentPopupAction && Et.currentPopupAction.cancel(),
                            Et.currentPopupAction = this
                    }

                    async executeNotNull() {
                        const e = await this.execute();
                        return v(e, this.auth, "internal-error"),
                            e
                    }

                    async onExecution() {
                        w(1 === this.filter.length, "Popup operations only handle one event");
                        const e = et();
                        this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], e),
                            this.authWindow.associatedEvent = e,
                            this.resolver._originValidation(this.auth).catch((e => {
                                    this.reject(e)
                                }
                            )),
                            this.resolver._isIframeWebStorageSupported(this.auth, (e => {
                                    e || this.reject(p(this.auth, "web-storage-unsupported"))
                                }
                            )),
                            this.pollUserCancellation()
                    }

                    get eventId() {
                        var e;
                        return (null === (e = this.authWindow) || void 0 === e ? void 0 : e.associatedEvent) || null
                    }

                    cancel() {
                        this.reject(p(this.auth, "cancelled-popup-request"))
                    }

                    cleanUp() {
                        this.authWindow && this.authWindow.close(),
                        this.pollId && window.clearTimeout(this.pollId),
                            this.authWindow = null,
                            this.pollId = null,
                            Et.currentPopupAction = null
                    }

                    pollUserCancellation() {
                        const e = () => {
                                var t, n;
                                (null === (n = null === (t = this.authWindow) || void 0 === t ? void 0 : t.window) || void 0 === n ? void 0 : n.closed) ? this.pollId = window.setTimeout((() => {
                                        this.pollId = null,
                                            this.reject(p(this.auth, "popup-closed-by-user"))
                                    }
                                ), 8e3) : this.pollId = window.setTimeout(e, Tt.get())
                            }
                        ;
                        e()
                    }
                }

                Et.currentPopupAction = null;
                const kt = "pendingRedirect"
                    , St = new Map;

                class Rt extends It {
                    constructor(e, t, n = !1) {
                        super(e, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], t, void 0, n),
                            this.eventId = null
                    }

                    async execute() {
                        let e = St.get(this.auth._key());
                        if (!e) {
                            try {
                                const t = await async function (e, t) {
                                    const n = Ct(t)
                                        , r = Ot(e);
                                    if (!await r._isAvailable())
                                        return !1;
                                    const i = "true" === await r._get(n);
                                    return await r._remove(n),
                                        i
                                }(this.resolver, this.auth) ? await super.execute() : null;
                                e = () => Promise.resolve(t)
                            } catch (t) {
                                e = () => Promise.reject(t)
                            }
                            St.set(this.auth._key(), e)
                        }
                        return this.bypassAuthState || St.set(this.auth._key(), (() => Promise.resolve(null))),
                            e()
                    }

                    async onAuthEvent(e) {
                        if ("signInViaRedirect" === e.type)
                            return super.onAuthEvent(e);
                        if ("unknown" !== e.type) {
                            if (e.eventId) {
                                const t = await this.auth._redirectUserForId(e.eventId);
                                if (t)
                                    return this.user = t,
                                        super.onAuthEvent(e);
                                this.resolve(null)
                            }
                        } else
                            this.resolve(null)
                    }

                    async onExecution() {
                    }

                    cleanUp() {
                    }
                }

                function At(e, t) {
                    St.set(e._key(), t)
                }

                function Ot(e) {
                    return q(e._redirectPersistence)
                }

                function Ct(e) {
                    return G(kt, e.config.apiKey, e.name)
                }

                async function Pt(e, t, n = !1) {
                    const r = ve(e)
                        , i = vt(r, t)
                        , s = new Rt(r, i, n)
                        , o = await s.execute();
                    return o && !n && (delete o.user._redirectEventId,
                        await r._persistUserIfCurrent(o.user),
                        await r._setRedirectUser(null, t)),
                        o
                }

                class Nt {
                    constructor(e) {
                        this.auth = e,
                            this.cachedEventUids = new Set,
                            this.consumers = new Set,
                            this.queuedRedirectEvent = null,
                            this.hasHandledPotentialRedirect = !1,
                            this.lastProcessedEventTime = Date.now()
                    }

                    registerConsumer(e) {
                        this.consumers.add(e),
                        this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, e) && (this.sendToConsumer(this.queuedRedirectEvent, e),
                            this.saveEventToCache(this.queuedRedirectEvent),
                            this.queuedRedirectEvent = null)
                    }

                    unregisterConsumer(e) {
                        this.consumers.delete(e)
                    }

                    onEvent(e) {
                        if (this.hasEventBeenHandled(e))
                            return !1;
                        let t = !1;
                        return this.consumers.forEach((n => {
                                this.isEventForConsumer(e, n) && (t = !0,
                                    this.sendToConsumer(e, n),
                                    this.saveEventToCache(e))
                            }
                        )),
                        this.hasHandledPotentialRedirect || !function (e) {
                            switch (e.type) {
                                case "signInViaRedirect":
                                case "linkViaRedirect":
                                case "reauthViaRedirect":
                                    return !0;
                                case "unknown":
                                    return Lt(e);
                                default:
                                    return !1
                            }
                        }(e) || (this.hasHandledPotentialRedirect = !0,
                        t || (this.queuedRedirectEvent = e,
                            t = !0)),
                            t
                    }

                    sendToConsumer(e, t) {
                        var n;
                        if (e.error && !Lt(e)) {
                            const r = (null === (n = e.error.code) || void 0 === n ? void 0 : n.split("auth/")[1]) || "internal-error";
                            t.onError(p(this.auth, r))
                        } else
                            t.onAuthEvent(e)
                    }

                    isEventForConsumer(e, t) {
                        const n = null === t.eventId || !!e.eventId && e.eventId === t.eventId;
                        return t.filter.includes(e.type) && n
                    }

                    hasEventBeenHandled(e) {
                        return Date.now() - this.lastProcessedEventTime >= 6e5 && this.cachedEventUids.clear(),
                            this.cachedEventUids.has(Dt(e))
                    }

                    saveEventToCache(e) {
                        this.cachedEventUids.add(Dt(e)),
                            this.lastProcessedEventTime = Date.now()
                    }
                }

                function Dt(e) {
                    return [e.type, e.eventId, e.sessionId, e.tenantId].filter((e => e)).join("-")
                }

                function Lt({type: e, error: t}) {
                    return "unknown" === e && "auth/no-auth-event" === (null == t ? void 0 : t.code)
                }

                const Mt = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/
                    , Ut = /^https?/;

                async function xt(e) {
                    if (e.config.emulator)
                        return;
                    const {authorizedDomains: t} = await async function (e, t = {}) {
                        return O(e, "GET", "/v1/projects", t)
                    }(e);
                    for (const e of t)
                        try {
                            if (Ft(e))
                                return
                        } catch (e) {
                        }
                    f(e, "unauthorized-domain")
                }

                function Ft(e) {
                    const t = _()
                        , {protocol: n, hostname: r} = new URL(t);
                    if (e.startsWith("chrome-extension://")) {
                        const i = new URL(e);
                        return "" === i.hostname && "" === r ? "chrome-extension:" === n && e.replace("chrome-extension://", "") === t.replace("chrome-extension://", "") : "chrome-extension:" === n && i.hostname === r
                    }
                    if (!Ut.test(n))
                        return !1;
                    if (Mt.test(e))
                        return r === e;
                    const i = e.replace(/\./g, "\\.");
                    return new RegExp("^(.+\\." + i + "|" + i + ")$", "i").test(r)
                }

                const Vt = new T(3e4, 6e4);

                function jt() {
                    const e = nt().___jsl;
                    if (null == e ? void 0 : e.H)
                        for (const t of Object.keys(e.H))
                            if (e.H[t].r = e.H[t].r || [],
                                e.H[t].L = e.H[t].L || [],
                                e.H[t].r = [...e.H[t].L],
                                e.CP)
                                for (let t = 0; t < e.CP.length; t++)
                                    e.CP[t] = null
                }

                let zt = null;

                function $t(e) {
                    return zt = zt || function (e) {
                        return new Promise(((t, n) => {
                                var r, i, s;

                                function o() {
                                    jt(),
                                        gapi.load("gapi.iframes", {
                                            callback: () => {
                                                t(gapi.iframes.getContext())
                                            }
                                            ,
                                            ontimeout: () => {
                                                jt(),
                                                    n(p(e, "network-request-failed"))
                                            }
                                            ,
                                            timeout: Vt.get()
                                        })
                                }

                                if (null === (i = null === (r = nt().gapi) || void 0 === r ? void 0 : r.iframes) || void 0 === i ? void 0 : i.Iframe)
                                    t(gapi.iframes.getContext());
                                else {
                                    if (!(null === (s = nt().gapi) || void 0 === s ? void 0 : s.load)) {
                                        const t = de("iframefcb");
                                        return nt()[t] = () => {
                                            gapi.load ? o() : n(p(e, "network-request-failed"))
                                        }
                                            ,
                                            he(`https://apis.google.com/js/api.js?onload=${t}`).catch((e => n(e)))
                                    }
                                    o()
                                }
                            }
                        )).catch((e => {
                                throw zt = null,
                                    e
                            }
                        ))
                    }(e),
                        zt
                }

                const Bt = new T(5e3, 15e3)
                    , Ht = "__/auth/iframe"
                    , Wt = "emulator/auth/iframe"
                    , qt = {
                        style: {
                            position: "absolute",
                            top: "-100px",
                            width: "1px",
                            height: "1px"
                        },
                        "aria-hidden": "true",
                        tabindex: "-1"
                    }
                    ,
                    Kt = new Map([["identitytoolkit.googleapis.com", "p"], ["staging-identitytoolkit.sandbox.googleapis.com", "s"], ["test-identitytoolkit.sandbox.googleapis.com", "t"]]);

                function Jt(e) {
                    const t = e.config;
                    v(t.authDomain, e, "auth-domain-config-required");
                    const n = t.emulator ? E(t, Wt) : `https://${e.config.authDomain}/${Ht}`
                        , s = {
                        apiKey: t.apiKey,
                        appName: e.name,
                        v: i.Jn
                    }
                        , o = Kt.get(e.config.apiHost);
                    o && (s.eid = o);
                    const a = e._getFrameworks();
                    return a.length && (s.fw = a.join(",")),
                        `${n}?${(0,
                            r.xO)(s).slice(1)}`
                }

                const Gt = {
                    location: "yes",
                    resizable: "yes",
                    statusbar: "yes",
                    toolbar: "no"
                };

                class Xt {
                    constructor(e) {
                        this.window = e,
                            this.associatedEvent = null
                    }

                    close() {
                        if (this.window)
                            try {
                                this.window.close()
                            } catch (e) {
                            }
                    }
                }

                function Yt(e, t, n, i = 500, s = 600) {
                    const o = Math.max((window.screen.availHeight - s) / 2, 0).toString()
                        , a = Math.max((window.screen.availWidth - i) / 2, 0).toString();
                    let c = "";
                    const u = Object.assign(Object.assign({}, Gt), {
                        width: i.toString(),
                        height: s.toString(),
                        top: o,
                        left: a
                    })
                        , l = (0,
                        r.z$)().toLowerCase();
                    n && (c = ee(l) ? "_blank" : n),
                    Q(l) && (t = t || "http://localhost",
                        u.scrollbars = "yes");
                    const h = Object.entries(u).reduce(((e, [t, n]) => `${e}${t}=${n},`), "");
                    if (function (e = (0,
                        r.z$)()) {
                        var t;
                        return se(e) && !!(null === (t = window.navigator) || void 0 === t ? void 0 : t.standalone)
                    }(l) && "_self" !== c)
                        return function (e, t) {
                            const n = document.createElement("a");
                            n.href = e,
                                n.target = t;
                            const r = document.createEvent("MouseEvent");
                            r.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null),
                                n.dispatchEvent(r)
                        }(t || "", c),
                            new Xt(null);
                    const d = window.open(t || "", c, h);
                    v(d, e, "popup-blocked");
                    try {
                        d.focus()
                    } catch (e) {
                    }
                    return new Xt(d)
                }

                const Qt = "__/auth/handler"
                    , Zt = "emulator/auth/handler"
                    , en = encodeURIComponent("fac");

                async function tn(e, t, n, s, o, a) {
                    v(e.config.authDomain, e, "auth-domain-config-required"),
                        v(e.config.apiKey, e, "invalid-api-key");
                    const c = {
                        apiKey: e.config.apiKey,
                        appName: e.name,
                        authType: n,
                        redirectUrl: s,
                        v: i.Jn,
                        eventId: o
                    };
                    if (t instanceof Ne) {
                        t.setDefaultLanguage(e.languageCode),
                            c.providerId = t.providerId || "",
                        (0,
                            r.xb)(t.getCustomParameters()) || (c.customParameters = JSON.stringify(t.getCustomParameters()));
                        for (const [e, t] of Object.entries(a || {}))
                            c[e] = t
                    }
                    if (t instanceof De) {
                        const e = t.getScopes().filter((e => "" !== e));
                        e.length > 0 && (c.scopes = e.join(","))
                    }
                    e.tenantId && (c.tid = e.tenantId);
                    const u = c;
                    for (const e of Object.keys(u))
                        void 0 === u[e] && delete u[e];
                    const l = await e._getAppCheckToken()
                        , h = l ? `#${en}=${encodeURIComponent(l)}` : "";
                    return `${function ({config: e}) {
                        if (!e.emulator)
                            return `https://${e.authDomain}/${Qt}`;
                        return E(e, Zt)
                    }(e)}?${(0,
                        r.xO)(u).slice(1)}${h}`
                }

                const nn = "webStorageSupport";
                const rn = class {
                        constructor() {
                            this.eventManagers = {},
                                this.iframes = {},
                                this.originValidationPromises = {},
                                this._redirectPersistence = Qe,
                                this._completeRedirectFn = Pt,
                                this._overrideRedirectResult = At
                        }

                        async _openPopup(e, t, n, r) {
                            var i;
                            w(null === (i = this.eventManagers[e._key()]) || void 0 === i ? void 0 : i.manager, "_initialize() not called before _openPopup()");
                            return Yt(e, await tn(e, t, n, _(), r), et())
                        }

                        async _openRedirect(e, t, n, r) {
                            await this._originValidation(e);
                            return function (e) {
                                nt().location.href = e
                            }(await tn(e, t, n, _(), r)),
                                new Promise((() => {
                                    }
                                ))
                        }

                        _initialize(e) {
                            const t = e._key();
                            if (this.eventManagers[t]) {
                                const {manager: e, promise: n} = this.eventManagers[t];
                                return e ? Promise.resolve(e) : (w(n, "If manager is not set, promise should be"),
                                    n)
                            }
                            const n = this.initAndGetManager(e);
                            return this.eventManagers[t] = {
                                promise: n
                            },
                                n.catch((() => {
                                        delete this.eventManagers[t]
                                    }
                                )),
                                n
                        }

                        async initAndGetManager(e) {
                            const t = await async function (e) {
                                const t = await $t(e)
                                    , n = nt().gapi;
                                return v(n, e, "internal-error"),
                                    t.open({
                                        where: document.body,
                                        url: Jt(e),
                                        messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
                                        attributes: qt,
                                        dontclear: !0
                                    }, (t => new Promise((async (n, r) => {
                                            await t.restyle({
                                                setHideOnLeave: !1
                                            });
                                            const i = p(e, "network-request-failed")
                                                , s = nt().setTimeout((() => {
                                                    r(i)
                                                }
                                            ), Bt.get());

                                            function o() {
                                                nt().clearTimeout(s),
                                                    n(t)
                                            }

                                            t.ping(o).then(o, (() => {
                                                    r(i)
                                                }
                                            ))
                                        }
                                    ))))
                            }(e)
                                , n = new Nt(e);
                            return t.register("authEvent", (t => {
                                    v(null == t ? void 0 : t.authEvent, e, "invalid-auth-event");
                                    return {
                                        status: n.onEvent(t.authEvent) ? "ACK" : "ERROR"
                                    }
                                }
                            ), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER),
                                this.eventManagers[e._key()] = {
                                    manager: n
                                },
                                this.iframes[e._key()] = t,
                                n
                        }

                        _isIframeWebStorageSupported(e, t) {
                            this.iframes[e._key()].send(nn, {
                                type: nn
                            }, (n => {
                                    var r;
                                    const i = null === (r = null == n ? void 0 : n[0]) || void 0 === r ? void 0 : r[nn];
                                    void 0 !== i && t(!!i),
                                        f(e, "internal-error")
                                }
                            ), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)
                        }

                        _originValidation(e) {
                            const t = e._key();
                            return this.originValidationPromises[t] || (this.originValidationPromises[t] = xt(e)),
                                this.originValidationPromises[t]
                        }

                        get _shouldInitProactively() {
                            return oe() || Z() || se()
                        }
                    }
                ;
                var sn = "@firebase/auth"
                    , on = "0.23.2";

                class an {
                    constructor(e) {
                        this.auth = e,
                            this.internalListeners = new Map
                    }

                    getUid() {
                        var e;
                        return this.assertAuthConfigured(),
                        (null === (e = this.auth.currentUser) || void 0 === e ? void 0 : e.uid) || null
                    }

                    async getToken(e) {
                        if (this.assertAuthConfigured(),
                            await this.auth._initializationPromise,
                            !this.auth.currentUser)
                            return null;
                        return {
                            accessToken: await this.auth.currentUser.getIdToken(e)
                        }
                    }

                    addAuthTokenListener(e) {
                        if (this.assertAuthConfigured(),
                            this.internalListeners.has(e))
                            return;
                        const t = this.auth.onIdTokenChanged((t => {
                                e((null == t ? void 0 : t.stsTokenManager.accessToken) || null)
                            }
                        ));
                        this.internalListeners.set(e, t),
                            this.updateProactiveRefresh()
                    }

                    removeAuthTokenListener(e) {
                        this.assertAuthConfigured();
                        const t = this.internalListeners.get(e);
                        t && (this.internalListeners.delete(e),
                            t(),
                            this.updateProactiveRefresh())
                    }

                    assertAuthConfigured() {
                        v(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth")
                    }

                    updateProactiveRefresh() {
                        this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh()
                    }
                }

                const cn = (0,
                    r.Pz)("authIdTokenMaxAge") || 300;
                let un = null;
                const ln = e => async t => {
                        const n = t && await t.getIdTokenResult()
                            , r = n && ((new Date).getTime() - Date.parse(n.issuedAtTime)) / 1e3;
                        if (r && r > cn)
                            return;
                        const i = null == n ? void 0 : n.token;
                        un !== i && (un = i,
                            await fetch(e, {
                                method: i ? "POST" : "DELETE",
                                headers: i ? {
                                    Authorization: `Bearer ${i}`
                                } : {}
                            }))
                    }
                ;

                function hn(e = (0,
                    i.Mq)()) {
                    const t = (0,
                        i.qX)(e, "auth");
                    if (t.isInitialized())
                        return t.getImmediate();
                    const n = function (e, t) {
                        const n = (0,
                            i.qX)(e, "auth");
                        if (n.isInitialized()) {
                            const e = n.getImmediate()
                                , i = n.getOptions();
                            if ((0,
                                r.vZ)(i, null != t ? t : {}))
                                return e;
                            f(e, "already-initialized")
                        }
                        return n.initialize({
                            options: t
                        })
                    }(e, {
                        popupRedirectResolver: rn,
                        persistence: [ft, Xe, Qe]
                    })
                        , s = (0,
                        r.Pz)("authTokenSyncURL");
                    if (s) {
                        const e = ln(s);
                        !function (e, t, n) {
                            (0,
                                r.m9)(e).beforeAuthStateChanged(t, n)
                        }(n, e, (() => e(n.currentUser))),
                            function (e, t, n, i) {
                                (0,
                                    r.m9)(e).onIdTokenChanged(t, n, i)
                            }(n, (t => e(t)))
                    }
                    const o = (0,
                        r.q4)("auth");
                    return o && we(n, `http://${o}`),
                        n
                }

                var dn;
                dn = "Browser",
                    (0,
                        i.Xd)(new a.wA("auth", ((e, {options: t}) => {
                            const n = e.getProvider("app").getImmediate()
                                , r = e.getProvider("heartbeat")
                                , i = e.getProvider("app-check-internal")
                                , {apiKey: s, authDomain: o} = n.options;
                            v(s && !s.includes(":"), "invalid-api-key", {
                                appName: n.name
                            });
                            const a = {
                                apiKey: s,
                                authDomain: o,
                                clientPlatform: dn,
                                apiHost: "identitytoolkit.googleapis.com",
                                tokenApiHost: "securetoken.googleapis.com",
                                apiScheme: "https",
                                sdkClientVersion: ae(dn)
                            }
                                , c = new ge(n, r, i, a);
                            return function (e, t) {
                                const n = (null == t ? void 0 : t.persistence) || []
                                    , r = (Array.isArray(n) ? n : [n]).map(q);
                                (null == t ? void 0 : t.errorMap) && e._updateErrorMap(t.errorMap),
                                    e._initializeWithPersistence(r, null == t ? void 0 : t.popupRedirectResolver)
                            }(c, t),
                                c
                        }
                    ), "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback(((e, t, n) => {
                            e.getProvider("auth-internal").initialize()
                        }
                    ))),
                    (0,
                        i.Xd)(new a.wA("auth-internal", (e => (e => new an(e))(ve(e.getProvider("auth").getImmediate()))), "PRIVATE").setInstantiationMode("EXPLICIT")),
                    (0,
                        i.KN)(sn, on, function (e) {
                        switch (e) {
                            case "Node":
                                return "node";
                            case "ReactNative":
                                return "rn";
                            case "Worker":
                                return "webworker";
                            case "Cordova":
                                return "cordova";
                            default:
                                return
                        }
                    }(dn)),
                    (0,
                        i.KN)(sn, on, "esm2017")
            }
        },
        function (e) {
            e.O(0, [7209], (function () {
                [4202, 4443, 30, 2759].map(e.E)
            }), 5);
            var t = 5822
            e(e.s = t)
        }
    ]
);
